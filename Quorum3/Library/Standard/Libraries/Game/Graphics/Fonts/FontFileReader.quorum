package Libraries.Game.Graphics.Fonts

use Libraries.System.File
use Libraries.System.BinaryFileReader
use Libraries.Containers.ByteArray
use Libraries.Containers.Support.ByteReader
use Libraries.Containers.Array
use Libraries.Containers.HashTable
use Libraries.Containers.Iterator
use Libraries.Compute.BigInteger
use Libraries.Compute.BitwiseOperations
use Libraries.Game.Graphics.Fonts.all
use Libraries.Game.GameStateManager

/*
The FontFileReader class is used to read font files. Currently it only supports
TrueType files (.ttf extension). TrueType files come in different formats, and
not all of these formats are supported at the moment. As a result, some TrueType
files will load and be read, but they will not display characters correctly.

Attribute: Example

    use Libraries.Game.Graphics.Fonts.all
    use Libraries.Game.Game
    use Libraries.System.File

    class Main is Game
        action Main
            StartGame()
        end

        action CreateGame
            FontFileReader reader
            File file
            // This is the directory for fonts on Mac
            file:SetWorkingDirectory("/Library/Fonts")
            file:SetPath("Arial.ttf")
            reader:Load(file)
        end
    end
*/
class FontFileReader
    /*ByteArray to store information read from the font file.*/
    ByteArray byteArray = undefined
    /*ByteReader that reads through the font file.*/
    ByteReader byteReader = undefined
    /*Termination null character.*/
    text NULL_TERMINATOR = ""
    /*TrueTypeFileInformation that maintains information about the font, as read from the file.*/
    TrueTypeFileInformation fileInformation
    /*CharacterMap that maintains individual character information, such as its UNICODE
    value, its glyph, and so on.*/
    CharacterMap characterMap
    /*KerningTable that maintains the kerning values between any two pairs of characters*/
    KerningTable kerningTable
    /*TrueTypeCollectionRecords that maintains human-readable information about the font file.*/
    TrueTypeCollectionRecords trueTypeTable

    // The QuorumStrategy stored here is the strategy that originally requested
    // the file to be read. We store it here so we can refer back to it to
    // finish font loading when we need to read a file asynchronously (i.e. the web).
    QuorumStrategy strategy = undefined

    on create
        NULL_TERMINATOR = NULL_TERMINATOR:GetUnicodeValue(0)
    end

    /*
    This action returns all the information read from the TrueType file.

    Attribute: Returns Returns a TrueTypeFileInformation containing all of the
    contents from the TrueType file.

    Attribute: Example
    
        use Libraries.Game.Graphics.Fonts.all
        use Libraries.Game.Game
        use Libraries.System.File

        class Main is Game
            action Main
                StartGame()
            end

            action CreateGame
                FontFileReader reader
                File file
                TrueTypeFileInformation information
                // This is the directory for fonts on Mac
                file:SetWorkingDirectory("/Library/Fonts")
                file:SetPath("Arial.ttf")
                reader:Load(file)
                information = reader:GetFileInformation()
            end
        end
    */
    action GetFileInformation() returns TrueTypeFileInformation
        return me:fileInformation
    end

    /*
    This action will load the font file if it is found on the system and then read
    all information from the file.

    Attribute: Parameter fileInformation The TrueType font file to read.

    Attribute: Example

        use Libraries.Game.Graphics.Fonts.all
        use Libraries.Game.Game
        use Libraries.System.File

        class Main is Game
            action Main
                StartGame()
            end

            action CreateGame
                FontFileReader reader
                File file
                // This is the directory for fonts on Mac
                file:SetWorkingDirectory("/Library/Fonts")
                file:SetPath("Arial.ttf")
                reader:Load(file)
            end
        end
    */
    action Load(File fileInformation, QuorumStrategy quorumStrategy)
        if not fileInformation:Exists()
            alert ("File doesn't exist")
            return now
        end

        strategy = quorumStrategy
        GameStateManager manager
        BinaryFileReader reader

        // If we are in a web browser, we have to load the file asynchronously.
        if manager:GetOperatingSystem() = "Web Browser"
            AsynchronousFontLoader loader
            loader:SetFontFileReader(me)
            reader:OpenForRead(fileInformation, loader)
        else
            reader:OpenForRead(fileInformation)
            byteArray = reader:ReadBytes()
            // True type font format (ttf) is big endian
            byteArray:SetBigEndian(true)
            byteReader = byteArray:GetByteReader()
            GetRecords()
        end
    end

    /*
    This action takes a BinaryFileReader which has already been used to open a
    file asynchronously and finishes reading in the information.
    */
    action CompleteAsynchronousLoading(BinaryFileReader openedFileReader)
        byteArray = openedFileReader:ReadBytes()
        // True type font format (ttf) is big endian
        byteArray:SetBigEndian(true)
        byteReader = byteArray:GetByteReader()
        GetRecords()

        // Now that we've finished reading in the file, inform the QuorumStrategy
        // that is using this reader that it can finish loading the Font.
        strategy:FinishFontLoading(me)
    end

    // This action is used in the GetRecords() when reading a .ttc file. .ttc files
    // have a different format from .ttf so must be read in differently. If this
    // needs to be modified, Microsoft has good documentation on .ttc files
    // in their OpenType documentation (I did not see anything on the Apple TrueType
    // documentation).
    private action GetTrueTypeCollectionRecords()
        fileInformation:SetTrueTypeCollectionFlag(true)
        integer majorVersionNumber = byteReader:NextTwoByteUnsignedInteger()
        integer minorVersionNumber = byteReader:NextTwoByteUnsignedInteger()
        integer numberOfFontsInCollection = byteReader:NextInteger()
        trueTypeTable:SetNumberOfFontsInCollection(numberOfFontsInCollection)
        Array<integer> offsetTable
        Array<TrueTypeCollectionData> collectionTables = trueTypeTable:GetCollectionTables()

        integer i = 0
        repeat while i < numberOfFontsInCollection
            TrueTypeCollectionData data
            integer value = byteReader:NextInteger()
            offsetTable:Add(value)
            collectionTables:Add(data)
            i = i + 1
        end

        trueTypeTable:SetOffsetTable(offsetTable)

        if majorVersionNumber = 2
            integer digitalSignatureTag = byteReader:NextInteger()
            integer digitalSignatureLength = byteReader:NextInteger()
            integer digitalSignatureOffset = byteReader:NextInteger()
        end

        //iterate over all the fonts in the file numberOfFontsInCollection
        i = 0
        repeat while i < numberOfFontsInCollection
            TrueTypeCollectionData data = collectionTables:Get(i)
            byteReader:SetPosition(offsetTable:Get(i))
            i = i + 1
            integer scalertype = byteReader:NextIntegerConvertFromUnsigned()
            fileInformation:SetScalerType(scalertype)
            //output "Scaler type is: " + scalertype

            fileInformation:SetNumberOfTables(byteReader:NextTwoByteUnsignedInteger())
            fileInformation:SetSearchRange(byteReader:NextTwoByteUnsignedInteger())
            fileInformation:SetEntrySelector(byteReader:NextTwoByteUnsignedInteger())
            fileInformation:SetRangeShift(byteReader:NextTwoByteUnsignedInteger())

            integer j = 0
            repeat while j < fileInformation:GetNumberOfTables()
                // these tables exist for every font, need to save them per font
                text tag = byteReader:NextTextRead(4)
                integer checksum = byteReader:NextIntegerConvertFromUnsigned()
                integer offset = byteReader:NextIntegerConvertFromUnsigned()
                integer length = byteReader:NextIntegerConvertFromUnsigned()

                fileInformation:AddFontTableDirectoryEntry(tag, checksum, offset, length)
                if tag = "cmap"
                    // reads character map table into hash table from CharacterMap class
                    ReadCharacterMapTable(byteReader, offset)
                elseif tag = "head"
                    // reads head table into hash table from GlobalFontInformationFlags class
                    ReadGlobalFontInformationTable(byteReader, offset)
                elseif tag = "kern"
                    // saves offset in file where kern table begins
                    ReadKerningTable(byteReader, offset)
                elseif tag = "glyf"
                    // saves offset in file where glyf table begins
                    fileInformation:SetGlyphOutlineTablePosition(offset)
                elseif tag = "loca"
                    // saves offset in file where loca table begins
                    fileInformation:SetGlyphDataLocationTablePosition(offset)
                elseif tag = "hhea"
                    // reads the hhea table, primarily used for maximum ascent and descent of a font
                    ReadHorizontalHeaderTable(byteReader, offset)
                elseif tag = "name"
                    // reads the name table, used to get human-readable text about the font, such as style name (i.e. bold)
                    ReadNameTable(byteReader, offset, data:GetNameRecords())
                end
                j = j + 1
            end
            data:SetAllTrueTypeInformation(fileInformation)
        end

        trueTypeTable:SetCollectionTables(collectionTables)
        fileInformation:SetTrueTypeCollectionRecords(trueTypeTable)
    end

    /*
    This action reads the name table of the ttf or ttc file. Useful primarily
    when dealing with the ttc files, as it allows us to differentiate between
    styles of a font in the collection (such as bold, light, etc.). For more
    information on the variables in this action, see the "name" table documentation
    on the Microsoft TrueType website.
    */
    private action ReadNameTable(ByteReader byteReader, integer nameTableOffset, Array<NameRecord> records)
        integer previousPosition = byteReader:GetPosition()
        byteReader:SetPosition(nameTableOffset)
        integer format = byteReader:NextTwoByteUnsignedInteger()
        integer numberOfNameRecords = byteReader:NextTwoByteUnsignedInteger()
        integer stringOffset = byteReader:NextTwoByteUnsignedInteger()
        integer i = 0

        integer platformID = 0
        integer platformSpecificID = 0
        integer languageID = 0
        integer nameID = 0
        integer length = 0
        integer offset = 0

        repeat while i < numberOfNameRecords
            NameRecord nameRecord
            platformID = byteReader:NextTwoByteUnsignedInteger()
            platformSpecificID = byteReader:NextTwoByteUnsignedInteger()
            languageID = byteReader:NextTwoByteUnsignedInteger()
            nameID = byteReader:NextTwoByteUnsignedInteger()
            length = byteReader:NextTwoByteUnsignedInteger()
            offset = byteReader:NextTwoByteUnsignedInteger()

            if nameID = 2       // this is the string that contains the style name, so add it to the record
                nameRecord:SetFileFormat(format)
                nameRecord:SetNumberOfNameRecords(numberOfNameRecords)
                nameRecord:SetStringOffset(stringOffset)
                nameRecord:SetPlatformID(platformID)
                nameRecord:SetPlatformSpecificID(platformSpecificID)
                nameRecord:SetLanguageID(languageID)
                nameRecord:SetNameID(nameID)
                nameRecord:SetWordLength(length)
                nameRecord:SetOffsetToWord(offset)
                text word = ""
                integer currentPosition = byteReader:GetPosition()
                byteReader:SetPosition(nameTableOffset + stringOffset + offset)
                
                if(platformID = 3 or platformID = 0) 
                    word = byteReader:NextTextReadUnicode(length)
                else 
                    word = byteReader:NextTextRead(length)
                end
                
                nameRecord:SetFontStyleName(word)

                records:Add(nameRecord)

                byteReader:SetPosition(currentPosition)
            end
            i = i + 1
        end

        byteReader:SetPosition(previousPosition)
    end

    /*
        Called by FontFileReader:Load() action.

        Reads entire file using class variable byteReader and saves all
        necessary information to fileInformation object from TrueTypeFileInformation 
        class, which includes the character map, global font information table, 
        glyph offset location table, and kern table. 
    */
    private action GetRecords
        if byteReader:CheckIfTrueTypeCollection()   // For .ttc files
            GetTrueTypeCollectionRecords()
        else    // .ttf file
            fileInformation:SetTrueTypeCollectionFlag(false)
            if byteReader:HasNextInteger()
                integer scalertype = byteReader:NextIntegerConvertFromUnsigned()
                fileInformation:SetScalerType(scalertype)
                fileInformation:SetNumberOfTables(byteReader:NextTwoByteUnsignedInteger())
                fileInformation:SetSearchRange(byteReader:NextTwoByteUnsignedInteger())
                fileInformation:SetEntrySelector(byteReader:NextTwoByteUnsignedInteger())
                fileInformation:SetRangeShift(byteReader:NextTwoByteUnsignedInteger())

                integer i = 0
                repeat while i < fileInformation:GetNumberOfTables()

                    text tag = byteReader:NextTextRead(4)
                    integer checksum = byteReader:NextIntegerConvertFromUnsigned()
                    integer offset = byteReader:NextIntegerConvertFromUnsigned()
                    integer length = byteReader:NextIntegerConvertFromUnsigned()

                    fileInformation:AddFontTableDirectoryEntry(tag, checksum, offset, length)
                    if tag = "cmap"
                        // reads character map table into hash table from CharacterMap class
                        ReadCharacterMapTable(byteReader, offset)
                    elseif tag = "head"
                        // reads head table into hash table from GlobalFontInformationFlags class
                        ReadGlobalFontInformationTable(byteReader, offset)
                    elseif tag = "kern"
                        // saves offset in file where kern table begins
                        ReadKerningTable(byteReader, offset)
                    elseif tag = "glyf"
                        // saves offset in file where glyf table begins
                        fileInformation:SetGlyphOutlineTablePosition(offset)
                    elseif tag = "loca"
                        // saves offset in file where loca table begins
                        fileInformation:SetGlyphDataLocationTablePosition(offset)
                    elseif tag = "hhea"
                        ReadHorizontalHeaderTable(byteReader, offset)
                    end
                    i = i + 1
                end
            end
        end
    end

    /*
    This action will return the Bezier curve glyph points of a given character. 
    If the character has already been read, it gets the points from the character
    map. Otherwise, it will get the data from the font file.

    Attribute: Parameter character The character to get the Bezier curve glyph points of.

    Attribute: Returns Returns the Bezier curve glyph points of the character.

    Attribute: Example

        use Libraries.Game.Graphics.Fonts.all
        use Libraries.Game.Game
        use Libraries.System.File

        class Main is Game
            action Main
                StartGame()
            end

            action CreateGame
                FontFileReader reader
                File file
                BezierCurveGlyphPoints points
                // This is the directory for fonts on Mac
                file:SetWorkingDirectory("/Library/Fonts")
                file:SetPath("Arial.ttf")
                reader:Load(file)
                points = reader:GetCharacterGlyphPoints("a")
            end
        end
    */
    action GetCharacterGlyphPoints(text character) returns BezierCurveGlyphPoints
        if not (character:GetSize() = 1)
            alert("I can only get one character at a time")
        end

        BezierCurveGlyphPoints glyphPoints

        if character = " " 
            return glyphPoints
        end

        if characterMap:GlyphPointsHaveBeenRead(character)
            glyphPoints = characterMap:GetGlyphPoints(character)
        else
            glyphPoints = GetCharacterGlyphPointsFromFile(character)
        end

        return glyphPoints
    end

    /*
        called by:
        DrawCharacters in MainGame (commented out)
        GetCharacterGlyph in FontFileReader (above)

        Locates and reads Bezier curve glyph points that outline the character glyph.

        Attribute: Parameter characterCode - integer ASCII value of character (value paired 
        with character in character map)

        Attribute: Returns BezierCurveGlyphPoints object containing information
        about a glyph's Bezier Curve outline
    */
    private action GetCharacterGlyphPointsFromFile(text character) returns BezierCurveGlyphPoints
        BezierCurveGlyphPoints glyphPoints
        integer characterCode = character:GetUnicodeInteger(0)

        integer glyphLocationTableIndex = FindCharacterGlyphIndex(characterCode, byteReader, fileInformation:GetCharacterMapTablePosition(), fileInformation:GetCharacterMapFormat())
        
        integer glyphTableOffset = 0
        check
            glyphTableOffset = GetGlyphOffset(glyphLocationTableIndex, byteReader, fileInformation:GetGlyphDataLocationTablePosition())
        detect e
            glyphTableOffset = 0
        end

        characterMap:SetGlyphIndexAndOffset(character, glyphLocationTableIndex, glyphTableOffset)

        check 
            glyphPoints = ReadGlyphPoints(byteReader, glyphTableOffset + fileInformation:GetGlyphOutlineTablePosition())
        detect e is Error
            return glyphPoints
        end
        characterMap:SetGlyphPoints(character, glyphPoints)

        return glyphPoints
    end

    /*
        Uses character map and passed character code to look up glyph index in 
        glyph offset location table.

        Attribute: Parameter characterCode - ASCII value of character

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file

        Attribute: Parameter characterMapTablePosition - byteReader position 
        of character map table in TrueType file

        Attribute: Parameter characterMapFormat - format of charcter map (must
        be 4)

        Attribute: Returns integer index of character in character map table?

        Attribute: example call: 
        integer index = FindCharacterGlyphIndex(characterCode, byteReader, fileInformation:GetCharacterMapTablePosition(), fileInformation:GetCharacterMapFormat())
    */
    private action FindCharacterGlyphIndex(integer characterCode, ByteReader byteReader, integer characterMapTablePosition, integer characterMapFormat) returns integer
        byteReader:SetPosition(characterMapTablePosition)

        // default is glyph not found
        integer glyphLocationTableIndex = 0

        if characterMapFormat = 4
            integer length = byteReader:NextTwoByteUnsignedInteger()
            integer language = byteReader:NextTwoByteUnsignedInteger()
            integer segmentCountTimesTwo = byteReader:NextTwoByteUnsignedInteger()
            integer segmentCount = segmentCountTimesTwo / 2
            integer searchRange = byteReader:NextTwoByteUnsignedInteger()
            integer entrySelector = byteReader:NextTwoByteUnsignedInteger()
            integer rangeShift = byteReader:NextTwoByteUnsignedInteger()
            
            integer i = 0
            integer position = -1
            integer endCharacterCode = -1
            
            repeat while i < segmentCount 
                endCharacterCode = byteReader:NextTwoByteUnsignedInteger()
                if endCharacterCode >= characterCode and position = -1   // set the first segment found, keep iterating to advance file reader enough
                    position = i
                end
                i = i + 1
            end
            
            integer pad = byteReader:NextTwoByteUnsignedInteger()

            if position = -1 // character not in the font, return missing character index
                return glyphLocationTableIndex
            else
                integer startCharacterCode = -1
                byteReader:SkipBytes(position * 2)  // array of 16 bit startCharacterCodes, we need to jump to the proper index
                startCharacterCode = byteReader:NextTwoByteUnsignedInteger()
                byteReader:SkipBytes((segmentCount - position - 1) * 2)
                
                if startCharacterCode <= characterCode  // character should be present, find it
                    integer idDelta = -1
                    integer idRangeOffset = -1

                    byteReader:SkipBytes(position * 2)
                    idDelta = byteReader:NextTwoByteUnsignedInteger()
                    byteReader:SkipBytes((segmentCount - position - 1) * 2)
                    
                    byteReader:SkipBytes(position * 2)
                    integer idRangeOffsetPosition = byteReader:GetPosition()
                    idRangeOffset = byteReader:NextTwoByteUnsignedInteger()
                    
                    if idRangeOffset not= 0 // this case not working right
                        integer glyphIndexAddress = idRangeOffset + 2 * (characterCode - startCharacterCode) + idRangeOffsetPosition
                        byteReader:SetPosition(glyphIndexAddress)
                        integer glyphID = byteReader:NextTwoByteUnsignedInteger()
                        if glyphID = 0
                            return glyphLocationTableIndex
                        else
                            glyphLocationTableIndex = (idDelta + glyphID) mod 65536
                        end
                    else
                        glyphLocationTableIndex = (idDelta + characterCode) mod 65536
                    end
                else        // character not in the font file, return missing character index
                    return glyphLocationTableIndex
                end
            end

        elseif characterMapFormat = 6
            integer tableLength = byteReader:NextTwoByteUnsignedInteger()
            integer languageCode = byteReader:NextTwoByteUnsignedInteger()
            integer firstCharacterCode = byteReader:NextTwoByteUnsignedInteger()
            integer entryCount = byteReader:NextTwoByteUnsignedInteger()
            
            integer endCharacterCode = firstCharacterCode + entryCount

            if characterCode < firstCharacterCode or characterCode > endCharacterCode
                glyphLocationTableIndex = 0
            else
                integer offset = characterCode - firstCharacterCode
                byteReader:SkipBytes(offset*2)      // each entry in the table is two bytes
                glyphLocationTableIndex = byteReader:NextTwoByteUnsignedInteger()
            end

        elseif characterMapFormat = 12 
            integer formatDecimal = byteReader:NextTwoByteUnsignedInteger() // format 12 files have an additional 2 bytes of info for the format that wasn't read before, so need to advance file
            integer tableLength = byteReader:NextInteger()
            integer languageCode = byteReader:NextInteger()
            integer numberOfGroups = byteReader:NextInteger()

            integer startCharacterCode = 0
            integer endCharacterCode = 0
            integer startGlyphID = 0
            integer i = 0
            
            repeat while i < numberOfGroups
                startCharacterCode = byteReader:NextInteger()
                endCharacterCode = byteReader:NextInteger()
                startGlyphID = byteReader:NextInteger()
                
                if endCharacterCode >= characterCode // the character we want is in this grouping
                    i = numberOfGroups
                end    
                i = i + 1
            end 
            
            glyphLocationTableIndex = startGlyphID + (characterCode - startCharacterCode)
        end

        return glyphLocationTableIndex
    end

    /*
        Uses Glyph Offset Location Table and glyph location table index to 
        look up offset of glyph in Glyph Table.
   
        Attribute: Parameter glyphLocationTableIndex - index of glyph in Character Map Table 

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file being read

        Attribute: Parameter glyphOffsetLocationTablePosition - byteReader position of Glyph Offset Location Table
        in TrueType file being read
       
        Attribute: Returns integer glyphTableOffset - location of glyph in Glyph Table in TrueType file

        Attribute: example call:
        integer glyphTableOffset = GetGlyphOffset(glyphLocationTableIndex, byteReader, fileInformation:GetGlyphDataLocationTablePosition())
    */
    private action GetGlyphOffset(integer glyphLocationTableIndex, ByteReader byteReader, integer glyphOffsetLocationTablePosition) returns integer
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(glyphOffsetLocationTablePosition)

        integer glyphTableOffset= -1
        if iteratorIsValid
            if fileInformation:GetIndexToLocationTableFormat() = 0 
                byteReader:SkipBytes(glyphLocationTableIndex*2)
                glyphTableOffset = byteReader:NextTwoByteUnsignedInteger() * 2
            else 
                byteReader:SkipBytes(glyphLocationTableIndex*4)
                glyphTableOffset = byteReader:NextIntegerConvertFromUnsigned()
            end
        end
        return glyphTableOffset
    end

    /*
    F2Dot14 is a number where the first two bits of a 16 bit integer are the 
    sign and non-decimal value, and the lower 14 bits are the fractional component
    of the number. See the Microsoft documentation on TrueType File Information
    for a better understanding.
    */
    private action ConvertIntegerToF2Dot14(integer scale) returns number
        BitwiseOperations ops
        integer sign = 0
        number newScale = 0
        integer decimalPortion = 0
        
        if scale < 0
            sign = -1
        else
            sign = 1
        end
        
        newScale = newScale + ops:And(ops:ShiftRight(scale, 14), 1)
        decimalPortion = ops:And(scale, ops:Negate(ops:ShiftLeft(-1, 14)))
        newScale = newScale + decimalPortion / 16384        // 16384 is the maximum representation possible with 14 bits

        return newScale * sign
    end

    /*
        Reads and stores information from given TrueType file about a single glyph's contours
        and the Bezier points outlining the glyph.

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file being read

        Attribute: Parameter glyphTablePosition - position of Glyph Table in 
        TrueType file being read

        Attribute: Returns BezierCurveGlyphPoints object containing information
        about a glyph's Bezier Curve outline

        Attribute: example call:
        glyph = ReadGlyph(byteReader, glyphTableOffset + fileInformation:GetGlyphTablePosition())
    */
    private action ReadGlyphPoints(ByteReader byteReader, integer glyphTablePosition) returns BezierCurveGlyphPoints
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(glyphTablePosition)
        BezierCurveGlyphPoints glyphPoints
        if iteratorIsValid
            integer numberOfContours = byteReader:NextTwoByteInteger()

            // Glyph bounding box
            integer xMin = byteReader:NextTwoByteInteger()
            integer yMin = byteReader:NextTwoByteInteger()
            integer xMax = byteReader:NextTwoByteInteger()
            integer yMax = byteReader:NextTwoByteInteger()
            
            glyphPoints:SetNumberOfContours(numberOfContours)
            glyphPoints:SetBoundingBox(xMin, yMin, xMax, yMax)

            if numberOfContours >= 0    // simple glyph case
                integer contourIterator = 0
                Array<integer> endPointsOfContours
                integer numberOfPoints = 0
                // Read contour endpoints
                repeat while contourIterator < numberOfContours
                    numberOfPoints = byteReader:NextTwoByteUnsignedInteger()
                    endPointsOfContours:Add(numberOfPoints)
                    contourIterator = contourIterator + 1
                end

                glyphPoints:SetContourEndpoints(endPointsOfContours)

                numberOfPoints = numberOfPoints + 1
                
                integer numberOfInstructions = byteReader:NextTwoByteUnsignedInteger()
                
                integer instructionCount = 0
                Array<integer> instructions
                repeat while instructionCount < numberOfInstructions
                    instructions:Add(byteReader:NextByteAsUnsignedInteger())
                    instructionCount = instructionCount + 1
                end

                // Read Glyph Coordinate flags
                Array<GlyphCoordinateFlag> glyphCoordinateFlagsArray
                repeat while glyphCoordinateFlagsArray:GetSize() < numberOfPoints
                    integer flags = byteReader:NextByteAsUnsignedInteger()
                    
                    GlyphCoordinateFlag glyphCoordinateFlag
                    glyphCoordinateFlag:SetFlags(flags)
                    glyphCoordinateFlagsArray:Add(glyphCoordinateFlag)

                    if glyphCoordinateFlag:RepetitionIsTrue()
                        integer repetitionCount = byteReader:NextByteAsUnsignedInteger()
                        repeat repetitionCount times
                            glyphCoordinateFlagsArray:Add(glyphCoordinateFlag)
                        end
                    end
                end

                // read x-Coordinates (relative)
                Array<integer> relativeXCoordinates
                integer flagIterator = 0
                repeat while relativeXCoordinates:GetSize() < numberOfPoints
                    GlyphCoordinateFlag currentFlag = glyphCoordinateFlagsArray:Get(flagIterator)

                    if currentFlag:XCoordinateIsOneByte()
                        integer currentX = byteReader:NextByteAsUnsignedInteger()
                        if not currentFlag:XCoordinateIsSame()
                            // is negative coordinate
                            currentX = currentX * -1
                        end
                        relativeXCoordinates:Add(currentX)
                    else    
                        if currentFlag:XCoordinateIsSame()
                            integer lastX = 0
                            relativeXCoordinates:Add(lastX)
                        else 
                            integer currentX = byteReader:NextTwoByteInteger()
                            relativeXCoordinates:Add(currentX)
                        end
                    end

                    flagIterator = flagIterator + 1
                end

                // read y-Coordinates (relative)
                Array<integer> relativeYCoordinates
                flagIterator = 0 // reset for y
                repeat while relativeYCoordinates:GetSize() < numberOfPoints
                    GlyphCoordinateFlag currentFlag = glyphCoordinateFlagsArray:Get(flagIterator)
                    
                    if currentFlag:YCoordinateIsOneByte()
                        integer currentY = 0
                        check
                            currentY = byteReader:NextByteAsUnsignedInteger()
                        detect e
                        end
                        if not currentFlag:YCoordinateIsSame()
                            // is negative coordinate
                            currentY = currentY * -1
                        end
                        relativeYCoordinates:Add(currentY)
                    elseif currentFlag:YCoordinateIsSame()
                        integer lastY = 0
                        relativeYCoordinates:Add(lastY)
                    else
                        integer currentY = 0
                        check
                            currentY = byteReader:NextTwoByteInteger()
                        detect e
                        end
                        relativeYCoordinates:Add(currentY)
                    end

                    flagIterator = flagIterator + 1
                end

                integer pointIterator = 0
                repeat while pointIterator < numberOfPoints
                    glyphPoints:AddNewPointRelativeToLast(relativeXCoordinates:Get(pointIterator), relativeYCoordinates:Get(pointIterator), glyphCoordinateFlagsArray:Get(pointIterator):IsOnCurve(), IsEndpoint(pointIterator, endPointsOfContours))
                    pointIterator = pointIterator + 1
                end

                glyphPoints:AddVirtualPoints()
            else    // compound glyph case, see Microsoft's documentation on the "glyf" table for relevant information
                glyphPoints:SetCompoundGlyph(true)
                Array<CompoundGlyphFlags> flags
                CompoundGlyphFlags glyphFlag
                integer instructionCount = 0
                Array<integer> instructions

                glyphFlag:SetFlags(byteReader:NextTwoByteUnsignedInteger())
                glyphFlag:SetGlyphIndex(byteReader:NextTwoByteUnsignedInteger())

                // The first two bits of the flags determine the type and use
                // of the arguments for a component
                if glyphFlag:GetArg1And2AreWords()
                    if glyphFlag:GetArgsAreXYValues()
                        glyphFlag:SetArgument1(byteReader:NextTwoByteInteger())
                        glyphFlag:SetArgument2(byteReader:NextTwoByteInteger())
                    else
                        glyphFlag:SetArgument1(byteReader:NextTwoByteUnsignedInteger())
                        glyphFlag:SetArgument2(byteReader:NextTwoByteUnsignedInteger())
                    end
                else
                    if glyphFlag:GetArgsAreXYValues()
                        glyphFlag:SetArgument1(byteReader:NextByteAsInteger())
                        glyphFlag:SetArgument2(byteReader:NextByteAsInteger())
                    else
                        glyphFlag:SetArgument1(byteReader:NextByteAsUnsignedInteger())
                        glyphFlag:SetArgument2(byteReader:NextByteAsUnsignedInteger())
                    end
                end

                if glyphFlag:GetWeHaveAScale()
                    glyphFlag:SetScale(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                elseif glyphFlag:GetWeHaveAnXAndYScale()
                    glyphFlag:SetXScale(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                    glyphFlag:SetYScale(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                elseif glyphFlag:GetWeHaveATwoByTwo()
                    glyphFlag:SetXScaleTransform(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                    glyphFlag:SetZeroOneScaleTransform(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                    glyphFlag:SetOneZeroScaleTransform(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                    glyphFlag:SetYScaleTransform(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                end

                flags:Add(glyphFlag)

                integer i = 0

                // If there are more components to the compound glyph, keep getting
                // their flags and arguments, store them all in the flag array
                repeat while i < flags:GetSize() and flags:Get(i):GetMoreComponents()
                    CompoundGlyphFlags glyphFlags
                    glyphFlags:SetFlags(byteReader:NextTwoByteUnsignedInteger())
                    glyphFlags:SetGlyphIndex(byteReader:NextTwoByteUnsignedInteger())

                    if glyphFlags:GetArg1And2AreWords()
                        if glyphFlags:GetArgsAreXYValues()
                            glyphFlags:SetArgument1(byteReader:NextTwoByteInteger())
                            glyphFlags:SetArgument2(byteReader:NextTwoByteInteger())
                        else
                            glyphFlags:SetArgument1(byteReader:NextTwoByteUnsignedInteger())
                            glyphFlags:SetArgument2(byteReader:NextTwoByteUnsignedInteger())
                        end
                    else
                        if glyphFlags:GetArgsAreXYValues()
                            glyphFlags:SetArgument1(byteReader:NextByteAsInteger())
                            glyphFlags:SetArgument2(byteReader:NextByteAsInteger())
                        else
                            glyphFlags:SetArgument1(byteReader:NextByteAsUnsignedInteger())
                            glyphFlags:SetArgument2(byteReader:NextByteAsUnsignedInteger())
                        end
                    end

                    if glyphFlags:GetWeHaveAScale()
                        glyphFlags:SetScale(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                    elseif glyphFlags:GetWeHaveAnXAndYScale()
                        glyphFlags:SetXScale(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                        glyphFlags:SetYScale(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                    elseif glyphFlags:GetWeHaveATwoByTwo()
                        glyphFlags:SetXScaleTransform(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                        glyphFlags:SetZeroOneScaleTransform(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                        glyphFlags:SetOneZeroScaleTransform(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                        glyphFlags:SetYScaleTransform(ConvertIntegerToF2Dot14(byteReader:NextTwoByteInteger()))
                    end

                    flags:Add(glyphFlags)
                    i = i + 1
                end

                i = 0

                // iterate over all components, reposition/scale them as needed,
                // add to BezierCurvePoints
                repeat while i < flags:GetSize()
                    BezierCurveGlyphPoints temporaryPoints
                    glyphFlag = flags:Get(i)
    
                    integer glyphTableOffset = GetGlyphOffset(glyphFlag:GetGlyphIndex(), byteReader, fileInformation:GetGlyphDataLocationTablePosition())
                    temporaryPoints = ReadGlyphPoints(byteReader, fileInformation:GetGlyphOutlineTablePosition() + glyphTableOffset)

                    // apply the offset first, then scale component
                    if glyphFlag:GetScaledComponentOffset()
                        if glyphFlag:GetArgsAreXYValues()
                            temporaryPoints:OffsetXY(glyphFlag:GetArgument1(), glyphFlag:GetArgument2())
                        else
                            // arguments are anchor points? Not yet implemented
                        end

                        if glyphFlag:GetWeHaveAScale()
                            temporaryPoints:ScalePoints(glyphFlag:GetScale())
                        elseif glyphFlag:GetWeHaveAnXAndYScale()
                            temporaryPoints:ScaleXAndYDifferently(glyphFlag:GetXScale(), glyphFlag:GetYScale())
                        elseif glyphFlag:GetWeHaveATwoByTwo()
                            // not yet implemented
                        end
                    // scale the glyph, then apply the offset
                    else
                        if glyphFlag:GetWeHaveAScale()
                            temporaryPoints:ScalePoints(glyphFlag:GetScale())
                        elseif glyphFlag:GetWeHaveAnXAndYScale()
                            temporaryPoints:ScaleXAndYDifferently(glyphFlag:GetXScale(), glyphFlag:GetYScale())
                        elseif glyphFlag:GetWeHaveATwoByTwo()
                            // not yet implemented
                        end

                        if glyphFlag:GetArgsAreXYValues()
                            temporaryPoints:OffsetXY(glyphFlag:GetArgument1(), glyphFlag:GetArgument2())
                        else
                            // arguments are anchor points? Not yet implemented
                        end
                    end

                    glyphPoints:AddToCompoundEndpoints(temporaryPoints:GetContourEndpoints())
                    glyphPoints:AddToCompoundPoints(temporaryPoints:GetPoints())

                    i = i + 1
                end
            end
        end
        byteReader:SetPosition(previousPosition)
        return glyphPoints
    end

    /*
        Called by AddNewPointRelativeToLast() in ReadGlyph() 
        Traverses passed array of endpoints to check if passed targetPoint is
        an endpoint.

        Attribute: Parameter targetPoint - the point to be checked if endpoint
        Attribute: Parameter endpoints - array of endpoints

        Attribute: Returns True if passed point is an endpoint
    */
    private action IsEndpoint (integer targetPoint, Array<integer> endpoints) returns boolean
        integer index = 0

        repeat while index < endpoints:GetSize()
            if targetPoint = endpoints:Get(index)
                return true
            end

            index = index + 1
        end
        return false
    end
  
    /*
        Traverses through TrueType file until encounters correct character
        map table of platform ID 0.

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file being read.

        Attribute: Parameter characterMapTablePosition - byteReader position of 
        beginning of character map table in TrueType file being read.
    */
    private action ReadCharacterMapTable(ByteReader byteReader, integer characterMapTablePosition)
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(characterMapTablePosition)
        if iteratorIsValid
            integer version = byteReader:NextTwoByteUnsignedInteger()
            integer numberOfSubtables = byteReader:NextTwoByteUnsignedInteger()

            integer platformID = -1
            integer platformSpecificID = -1
            integer characterMapOffset = -1

            integer characterMapSubtable = 0
            integer tablePosition = byteReader:GetPosition()
            repeat while characterMapSubtable < numberOfSubtables
                integer tempPlatformID = byteReader:NextTwoByteUnsignedInteger()
                integer tempPlatformSpecificID= byteReader:NextTwoByteUnsignedInteger()
                integer tempCharacterMapOffset = byteReader:NextIntegerConvertFromUnsigned()

                characterMapSubtable = characterMapSubtable + 1

                // The idea here is to use a more generalized and robust cmap table when possible.
                // There are 4 platform ID options, with 1 being deprecated. Of these, Unicode
                // is the most general and useful, followed by Windows, and finally Mac. Each of these
                // platform IDs have encoding IDs that let us know how the tables are encoded. For example,
                // some tables may be unicode UCS-4, which encompasses every current unicode character,
                // while some may be UCS-2, which covers many but not all characters. The ordering here
                // is based on the recommendation from the "cmap" table documentation on the Apple
                // website. We only need one cmap table, and we want the best one the file has,
                // and these conditionals are intended to get us the best one. For more information,
                // read the Apple or Microsoft documentation on the "cmap" table. 
                if tempPlatformID = 0
                    if tempPlatformSpecificID = 4
                        platformID = tempPlatformID
                        platformSpecificID = tempPlatformSpecificID
                        characterMapOffset = tempCharacterMapOffset
                        characterMapSubtable = numberOfSubtables
                    elseif tempPlatformSpecificID < 4 and platformSpecificID not= 4
                        platformID = tempPlatformID
                        platformSpecificID = tempPlatformSpecificID
                        characterMapOffset = tempCharacterMapOffset
                    end
                elseif tempPlatformID = 3 and platformID not= 0
                    if tempPlatformSpecificID = 10
                        platformID = tempPlatformID
                        platformSpecificID = tempPlatformSpecificID
                        characterMapOffset = tempCharacterMapOffset
                    elseif tempPlatformSpecificID = 1 and platformSpecificID not= 10
                        platformID = tempPlatformID
                        platformSpecificID = tempPlatformSpecificID
                        characterMapOffset = tempCharacterMapOffset
                    elseif tempPlatformSpecificID = 0 and platformSpecificID not= 10 and platformSpecificID not= 1
                        platformID = tempPlatformID
                        platformSpecificID = tempPlatformSpecificID
                        characterMapOffset = tempCharacterMapOffset
                    end
                elseif tempPlatformID = 1 and platformID not= 0 and platformID not= 3
                    platformID = tempPlatformID
                    platformSpecificID = tempPlatformSpecificID
                    characterMapOffset = tempCharacterMapOffset
                end
            end
            ReadCharacterMapMapping(byteReader, characterMapTablePosition + characterMapOffset)
        end
        byteReader:SetPosition(previousPosition)
    end

    /*
        Saves offset of character map in TrueType file to class's 
        TrueTypeFileInformation object.

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file being read.

        Attribute: Parameter characterMapOffsetPosition - byteReader position of character map
        in TrueType file being read.
    */
    private action ReadCharacterMapMapping(ByteReader byteReader, integer characterMapOffsetPosition)
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(characterMapOffsetPosition)
        if iteratorIsValid
            // Formats have to be read differently, so the format has to be saved
            integer format = byteReader:NextTwoByteUnsignedInteger()
            integer cmapPosition = byteReader:GetPosition()
            fileInformation:SetCharacterMapTablePosition(cmapPosition, format)
        end
        byteReader:SetPosition(previousPosition)
    end

    /*
        called by:
        GetRecords in FontFileReader
    
        Reads heading kern table information from given TrueType file
        into class's TrueTypeFileInformation object. Saves offset of kern tables in class 
        TrueTypeFileInformation object. 

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file being read

        Attribute: Parameter kernTablePosition - byteReader position of 
        kernTable in TrueType file being read

        kerning table reference: https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kern.html
    */
    private action ReadKerningTable (ByteReader byteReader, integer kernTablePosition)
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(kernTablePosition)
        if iteratorIsValid
            fileInformation:SetKerningSubtablePosition(kernTablePosition)
            
            integer version = byteReader:NextTwoByteUnsignedInteger()
            integer numberOfSubtables = byteReader:NextTwoByteUnsignedInteger()

            integer kerningSubtable = 0            
            repeat while kerningSubtable < numberOfSubtables
                
                BitwiseOperations bitwiseOperation
                integer length = byteReader:NextIntegerConvertFromUnsigned()
                integer coverage = byteReader:NextTwoByteUnsignedInteger()
                integer format = bitwiseOperation:And(coverage, 65280)            // use mask value 0x00ff
                
                // Format 0: Ordered List of Kerning Pairs
                if format = 0
                    ReadKerningSubtableFormat0(byteReader, byteReader:GetPosition())
                end
                kerningSubtable = kerningSubtable + 1
            end 
        end
        byteReader:SetPosition(previousPosition)
    end

    /*
    This action reads the Horizontal Header (hhea) table from the font file.
    */  
    private action ReadHorizontalHeaderTable(ByteReader byteReader, integer horizontalHeaderPosition)
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(horizontalHeaderPosition)
        if iteratorIsValid
            fileInformation:SetHorizontalHeaderTablePosition(horizontalHeaderPosition)

            integer version = byteReader:NextTwoByteUnsignedInteger()
            integer versionDecimal = byteReader:NextTwoByteUnsignedInteger()
            integer ascent = byteReader:NextTwoByteInteger()
            fileInformation:SetMaximumAscent(ascent)
            integer descent = byteReader:NextTwoByteInteger()
            fileInformation:SetMaximumDescent(descent)
            integer lineGap = byteReader:NextTwoByteInteger()
            fileInformation:SetLineGap(lineGap)
        end

        byteReader:SetPosition(previousPosition)
    end

    /* 
        called by: 
        ReadKernTables in FontFileReader (above).

        Reads and stores kerning values to kerning table object in class's
        TrueTypeFileInformation object.

        Attribute: Parameter byteReader - used to travers ethrough the binary
        TrueType file being read.

        Attribute: Parameter kerningValuesPosition - byteReader position of
        beginning of kerning values in TrueType file being read.
    */
    private action ReadKerningSubtableFormat0(ByteReader byteReader, integer kerningSubtablePosition)
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(kerningSubtablePosition)

        if iteratorIsValid
            integer nPairs = byteReader:NextTwoByteUnsignedInteger()
            integer searchRange = byteReader:NextTwoByteUnsignedInteger()
            integer entrySelector = byteReader:NextTwoByteUnsignedInteger()
            integer rangeShift = byteReader:NextTwoByteUnsignedInteger()

            integer pairIterator = 0
            repeat while pairIterator < nPairs
                integer leftCharacterGlyphIndex = byteReader:NextTwoByteUnsignedInteger()
                integer rightCharacterGlyphIndex = byteReader:NextTwoByteUnsignedInteger()
                integer kerningValue = byteReader:NextTwoByteInteger()
     
                number kerningValueNumber = kerningValue / 1000
                kerningTable:Add(leftCharacterGlyphIndex, rightCharacterGlyphIndex, kerningValue)
                
                pairIterator = pairIterator + 1
            end 
        end
        byteReader:SetPosition(previousPosition)
    end

    /*
    This action returns the kerning value between two given characters.

    Attribute: Parameter lefthandCharacter The lefthand character of the pair.

    Attribute: Parameter righthandCharacter The righthand character of the pair.

    Attribute: Returns Returns the kerning value between two given characters.

    Attribute: Example

        use Libraries.Game.Graphics.Fonts.all
        use Libraries.Game.Game
        use Libraries.System.File

        class Main is Game
            action Main
                StartGame()
            end

            action CreateGame
                FontFileReader reader
                File file
                // This is the directory for fonts on Mac
                file:SetWorkingDirectory("/Library/Fonts")
                file:SetPath("Arial.ttf")
                reader:Load(file)
                integer kerning = reader:GetKerningValue("A", "V")
                output kerning
            end
        end
    */
    action GetKerningValue(text lefthandCharacter, text righthandCharacter) returns integer
        integer kerningValue = 0
        integer leftCharacterGlyphIndex = -1
        integer rightCharacterGlyphIndex = -1

        // get left character glyph index
        if characterMap:GlyphPointsHaveBeenRead(lefthandCharacter)
            leftCharacterGlyphIndex = characterMap:GetGlyphIndex(lefthandCharacter)
        else
            integer characterCode = characterMap:GetCharacterCode(lefthandCharacter)
            leftCharacterGlyphIndex = FindCharacterGlyphIndex(characterCode, byteReader, fileInformation:GetCharacterMapTablePosition(), fileInformation:GetCharacterMapFormat())
        end
        
        // get right character glyph index
        if characterMap:GlyphPointsHaveBeenRead(righthandCharacter)
            rightCharacterGlyphIndex = characterMap:GetGlyphIndex(righthandCharacter)
        else
            integer characterCode = characterMap:GetCharacterCode(righthandCharacter)
            rightCharacterGlyphIndex = FindCharacterGlyphIndex(characterCode, byteReader, fileInformation:GetCharacterMapTablePosition(), fileInformation:GetCharacterMapFormat())     
        end

        // retrieve kerning value from kerning table
        if leftCharacterGlyphIndex > -1 and rightCharacterGlyphIndex > -1 and kerningTable:HasPair(leftCharacterGlyphIndex, rightCharacterGlyphIndex)
            kerningValue = me:kerningTable:GetKerningValue(leftCharacterGlyphIndex, rightCharacterGlyphIndex)
        end
        return kerningValue
    end

    /*
    This action returns the kerning table, containing kerning values for all
    characters, of the font.

    Attribute: Returns Returns the kerning table of the font.

    Attribute: Example

        use Libraries.Game.Graphics.Fonts.all
        use Libraries.Game.Game
        use Libraries.System.File

        class Main is Game
            action Main
                StartGame()
            end

            action CreateGame
                FontFileReader reader
                File file
                KerningTable table
                // This is the directory for fonts on Mac
                file:SetWorkingDirectory("/Library/Fonts")
                file:SetPath("Arial.ttf")
                reader:Load(file)
                table = reader:GetKerningTable()
            end
        end
    */
    action GetKerningTable() returns KerningTable
        return me:kerningTable
    end

    /*
        Reads and stores information from Global Font Information Table, which 
        contains general measurements that apply to all characters of the font

        Attribute: Parameter byteReader - used to traverse through the binary
        TrueType file being read

        Attribute: Parameter GlobalFontInformationTablePosition - position of Global Font Information Table
        in TrueType file being read
    */
    private action ReadGlobalFontInformationTable (ByteReader byteReader, integer GlobalFontInformationTablePosition)
        integer previousPosition = byteReader:GetPosition()
        boolean iteratorIsValid = byteReader:SetPosition(GlobalFontInformationTablePosition)
        if iteratorIsValid
            // The first two entries are 16.16 fixed point values, that I don't know
            // how to deal with yet. They contain the version number only, so I am
            // going to skip them  (2x32 bit = 8 byte)
            byteReader:SkipBytes(8)
            integer checksum = byteReader:NextIntegerConvertFromUnsigned()
            integer magicNumber = byteReader:NextIntegerConvertFromUnsigned()
            
            // these are bitflags with specific meanings. See https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6head.html
            integer flags = byteReader:NextTwoByteUnsignedInteger()
            fileInformation:SetGlobalFontInformationFlags(flags)

            integer unitsPerEm = byteReader:NextTwoByteUnsignedInteger()
            fileInformation:SetUnitsPerEm(unitsPerEm)

            fileInformation:SetCreatedDate(byteReader:NextLong())
            fileInformation:SetLastChangedDate(byteReader:NextLong())

            Signed16BitFontUnit xMin
            Signed16BitFontUnit yMin
            Signed16BitFontUnit xMax
            Signed16BitFontUnit yMax

            xMin:SetFontUnit(byteReader:NextTwoByteInteger())
            yMin:SetFontUnit(byteReader:NextTwoByteInteger())
            xMax:SetFontUnit(byteReader:NextTwoByteInteger())
            yMax:SetFontUnit(byteReader:NextTwoByteInteger())

            fileInformation:SetXMinimum(xMin)
            fileInformation:SetYMinimum(yMin)
            fileInformation:SetXMaximum(xMax)
            fileInformation:SetYMaximum(yMax)
            
            // Flags again, this time macStyle.
            integer macStyleFlags = byteReader:NextTwoByteUnsignedInteger()
            fileInformation:SetMacStyleFlags(macStyleFlags)

            // lowest recommended points per EM
            integer lowestRecommendedPixelsPerEm = byteReader:NextTwoByteUnsignedInteger()
            fileInformation:SetLowestRecommendedPixelsPerEm(lowestRecommendedPixelsPerEm)

            // contains small integer giving info on direction
            // 0 : mixed; 1: only left to right; 2: like 1 but contains neutrals
            // -1: right to left; -2: like -1 but contains neutrals
            integer fontDirectionHint = byteReader:NextTwoByteUnsignedInteger()
            fileInformation:SetFontDirectionHint(fontDirectionHint)

            integer indexToLocationTableFormat = byteReader:NextTwoByteInteger()
            fileInformation:SetIndexToLocationTableFormat(indexToLocationTableFormat)
            integer glyphDataFormat = byteReader:NextTwoByteInteger()    
        end
        byteReader:SetPosition(previousPosition)
    end
end