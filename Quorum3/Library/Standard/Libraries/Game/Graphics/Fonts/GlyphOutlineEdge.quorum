package Libraries.Game.Graphics.Fonts

use Libraries.Containers.Array
use Libraries.Compute.Math
use Libraries.Game.Graphics.Fonts.all
use Libraries.Language.Support.CompareResult

class GlyphOutlineEdge
    Math math
    Array<integer> scanlines
    Array<XIntercept> scanlineIntercepts
    Array<number> bezierCurveYIntercepts
    number startXPosition = 0
    number startYPosition = 0
    number endXPosition = 0
    number endYPosition = 0
    number controlXPosition = 0
    number controlYPosition = 0
    integer yMinimum = 0
    integer yMaximum = 0
    boolean isBezierCurve = false
    boolean isAscending = false
    boolean isHorizontal = false
    boolean isVertical = false
    number slope = 0.0
    number yIntercept = 0.0
    boolean movingLeftToRight = false
    number currentXPosition = 0.0
    number currentStartXPosition = 0.0
    number currentEndXPosition = 0.0
    integer currentYPosition = 0
    integer edgeNumber = 0
    boolean isYMonotonic = false
    number subEdgeStartX = 0.0
    number subEdgeStartY = 0.0
    number subEdgeEndX = 0.0
    number subEdgeEndY = 0.0
    number subEdgeControlX = 0.0
    number subEdgeControlY = 0.0

    action GetCurrentStartXPosition() returns number
        return currentStartXPosition
    end

    action GetCurrentEndXPosition() returns number
        return currentEndXPosition
    end

    action GetSubEdgeStartX() returns number
        return subEdgeStartX
    end

    action GetSubEdgeStartY() returns number
        return subEdgeStartY
    end

    action GetSubEdgeEndX() returns number
        return subEdgeEndX
    end

    action GetSubEdgeEndY() returns number
        return subEdgeEndY
    end

    action GetBezierCurveYIntercepts() returns Array<number>
        return bezierCurveYIntercepts
    end

    action GetEdgeNumber() returns integer
        return edgeNumber
    end

    action GetIsYMonotonic() returns boolean
        return isYMonotonic
    end

    // used to sort the active edge list by ascending x values
    action Compare(Object object) returns CompareResult
        CompareResult result
        if object is GlyphOutlineEdge
            GlyphOutlineEdge edge = cast(GlyphOutlineEdge, object)
            if currentXPosition > edge:GetCurrentXPosition()
                result:result = result:LARGER
            elseif currentXPosition < edge:GetCurrentXPosition()
                result:result = result:SMALLER
            else
                result:result = result:EQUAL
            end
            return result
        else
            return parent:Object:Compare(object)
        end
    end

    action GetCurrentXPosition() returns number
        return currentXPosition
    end

    action CalculateCurrentXPosition()
        // y = mx + b => (y-b)/m = x
        if not isBezierCurve
            if slope not= 0 and not isVertical // not vertical and not horizontal
                currentXPosition = (currentYPosition - yIntercept) / slope
                if movingLeftToRight
                    if currentXPosition > endXPosition
                        currentXPosition = endXPosition
                    elseif currentXPosition < startXPosition
                        currentXPosition = startXPosition
                    end
                else
                    if currentXPosition > startXPosition
                        currentXPosition = startXPosition
                    elseif currentXPosition < endXPosition
                        currentXPosition = endXPosition
                    end
                end
            elseif isVertical
                currentXPosition = startXPosition
            // horizontal edges aren't processed
            end
        else    // bezier curve case
            // two ways: create two look-up tables and binary search the y values 
            // to find the intercept I need. This uses the weighted Bezier curve
            // formula. FreeType does not do it this way?
            // second way: FreeType subdivides the arc into smaller Bezier arcs
            // until the subdivision is too small to cross more than one span line
            // Need to think about pros and cons of both approaches and pick one
            // Not sure how you would find the x-intercept of an even smaller
            // Bezier curve without usiing the weighted formula?
            
            FindBezierCurveXIntercepts()

        end
    end
    
    action FindBezierCurveXIntercepts()
        // General algorithm idea:
        // Subdivide the Bezier curve into two smaller Bezier curves.
        // Discard the one that does not fit the current y scanline.
        // Continue the process until you have a Bezier curve where both endpoints have y values that are equal to the scanline.

        Math math
        boolean foundSubCurve = false
        number xIntercept = 0.0
        number Q1x = 0.0
        number Q1y = 0.0
        number Q2x = 0.0
        number Q2y = 0.0
        number Q3x = 0.0
        number Q3y = 0.0
        number R1x = 0.0
        number R1y = 0.0
        number R2x = 0.0
        number R2y = 0.0
        number R3x = 0.0
        number R3y = 0.0
        number P1x = startXPosition
        number P1y = startYPosition
        number P2x = controlXPosition
        number P2y = controlYPosition
        number P3x = endXPosition
        number P3y = endYPosition

        //output "before first repeat"
        repeat while foundSubCurve = false
            // Given a Bezier curve P1, P2, P3, two subarcs, Q1, Q2, Q3 and R1, R2, R3, are defined as follows:
            // Q1 = P1, Q2 = (P1+P2)/2, Q3 = R1 = (Q2+R2)/2, R3 = P3, R2 = (P2+P3)/2
            
            // create new Bezier curves
            Q1x = P1x
            Q1y = P1y
            Q2x = (P1x + P2x)/2
            Q2y = (P1y + P2y)/2
            R3x = P3x
            R3y = P3y
            R2x = (P2x + P3x)/2
            R2y = (P2y + P3y)/2
            Q3x = (Q2x + R2x)/2
            Q3y = (Q2y + R2y)/2
            R1x = Q3x
            R1y = Q3y

            if currentYPosition > math:Round(Q1y) and currentYPosition > math:Round(R3y)
                return now
            end
            //output "CurrentY: " + currentYPosition + " q1x: " + Q1x + " q1y: " + Q1y + " q2x: " + Q2x + " q2y: " + Q2y + " q3x: " + Q3x + " q3y: " + Q3y + ", edge #" + edgeNumber
            //output "CurrentY: " + currentYPosition + " r1x: " + R1x + " r1y: " + R1y + " r2x: " + R2x + " r2y: " + R2y + " r3x: " + R3x + " r3y: " + R3y + ", edge #" + edgeNumber
            // check if one of the subdivisions has been found
            if math:Round(Q1y) = currentYPosition and math:Round(Q3y) = currentYPosition
                foundSubCurve = true
                subEdgeStartX = Q1x
                subEdgeStartY = Q1y
                subEdgeEndX = Q3x
                subEdgeEndY = Q3y
                subEdgeControlX = Q2x
                subEdgeControlY = Q2y
            elseif math:Round(R1y) = currentYPosition and math:Round(R3y) = currentYPosition
                foundSubCurve = true
                subEdgeStartX = R1x
                subEdgeStartY = R1y
                subEdgeEndX = R3x
                subEdgeEndY = R3y
                subEdgeControlX = R2x
                subEdgeControlY = R2y
            else    // not found, have to subdivide
                if isAscending
                    if currentYPosition >= math:Round(Q1y) and currentYPosition <= math:Round(Q3y)  // covered by first subarc
                        P1x = Q1x
                        P1y = Q1y
                        P2x = Q2x
                        P2y = Q2y
                        P3x = Q3x
                        P3y = Q3y
                    else        // covered by second subarc
                        P1x = R1x
                        P1y = R1y
                        P2x = R2x
                        P2y = R2y
                        P3x = R3x
                        P3y = R3y
                    end
                else
                    if currentYPosition <= math:Round(Q1y) and currentYPosition >= math:Round(Q3y)  // covered by first subarc
                        P1x = Q1x
                        P1y = Q1y
                        P2x = Q2x
                        P2y = Q2y
                        P3x = Q3x
                        P3y = Q3y  
                    else        // covered by second subarc
                        P1x = R1x
                        P1y = R1y
                        P2x = R2x
                        P2y = R2y
                        P3x = R3x
                        P3y = R3y
                    end
                end
            end
        end
        //output "After first repeat"
        // have subarc that falls on the scanline, find its intercepts
        // treat it as a straight line, add all x values falling on this y
        Array<number> newIntercepts

        // new idea: subdivide the small arc until it is on a single pixel, add that y value to the intercepts
        
        number startX = 0
        number endX = 0
        number startY = 0
        number endY = 0
        foundSubCurve = false
        boolean movingLeftToRight = false
        
        if subEdgeStartX < subEdgeEndX
            startX = subEdgeStartX
            endX = subEdgeEndX
            startY = subEdgeStartY
            endY = subEdgeEndY
            movingLeftToRight = true
        elseif subEdgeStartX > subEdgeEndX
            startX = subEdgeEndX
            endX = subEdgeStartX
            startY = subEdgeEndY
            endY = subEdgeStartY
            movingLeftToRight = false
        else
            startX = subEdgeStartX
            endX = subEdgeEndX
            startY = subEdgeStartY
            endY = subEdgeEndY
            movingLeftToRight = true
        end

        if movingLeftToRight
            if startX < startXPosition
                startX = startXPosition
            end
            if endX > endXPosition
                endX = endXPosition
            end
        else
            if startX < endXPosition
                startX = endXPosition
            end
            if endX > startXPosition
                endX = startXPosition
            end
        end 

        integer currentX = cast(integer, math:Floor(startX)) + 1
        newIntercepts:Add(startY)

        P1x = subEdgeStartX
        P2x = subEdgeControlX
        P3x = subEdgeEndX
        P1y = subEdgeStartY
        P2y = subEdgeControlY
        P3y = subEdgeEndY
        //output "before second repeat"
        repeat while currentX < math:Floor(endX)
            foundSubCurve = false
            //output "before inner repeat"
            repeat while not foundSubCurve
                Q1x = P1x
                Q1y = P1y
                Q2x = (P1x + P2x)/2
                Q2y = (P1y + P2y)/2
                R3x = P3x
                R3y = P3y
                R2x = (P2x + P3x)/2
                R2y = (P2y + P3y)/2
                Q3x = (Q2x + R2x)/2
                Q3y = (Q2y + R2y)/2
                R1x = Q3x
                R1y = Q3y

                //output "CurrentX : " + currentX + ", Q1x: " + Q1x + ", Q3x: " + Q3x + ", R1x: " + R1x + ", R3x: " + R3x

                if math:Round(Q1x) = currentX and math:Round(Q3x) = currentX
                    foundSubCurve = true
                    newIntercepts:Add((Q1y + Q3y)/2)
                elseif math:Round(R1x) = currentX and math:Round(R3x) = currentX
                    foundSubCurve = true
                    newIntercepts:Add((R1y + R3y)/2)
                else    // not found, have to subdivide
                    if movingLeftToRight    // Q1x < R3x
                        if currentX >= math:Round(Q1x) and currentX <= math:Round(Q3x)  // covered by first subarc
                            P1x = Q1x
                            P1y = Q1y
                            P2x = Q2x
                            P2y = Q2y
                            P3x = Q3x
                            P3y = Q3y
                        else        // covered by second subarc
                            P1x = R1x
                            P1y = R1y
                            P2x = R2x
                            P2y = R2y
                            P3x = R3x
                            P3y = R3y
                        end
                    else
                        if currentX <= math:Round(Q1x) and currentX >= math:Round(Q3x)
                            P1x = Q1x
                            P1y = Q1y
                            P2x = Q2x
                            P2y = Q2y
                            P3x = Q3x
                            P3y = Q3y  
                        else
                            P1x = R1x
                            P1y = R1y
                            P2x = R2x
                            P2y = R2y
                            P3x = R3x
                            P3y = R3y
                        end
                    end
                end
            end

            P1x = subEdgeStartX
            P2x = subEdgeControlX
            P3x = subEdgeEndX
            P1y = subEdgeStartY
            P2y = subEdgeControlY
            P3y = subEdgeEndY
            currentX = currentX + 1
            //output "After inner repeat"
        end
        //output "After second repeat"

        newIntercepts:Add(endY)
        bezierCurveYIntercepts = newIntercepts
        currentXPosition = startX
        currentStartXPosition = startX
        currentEndXPosition = endX
        //output "After setting values"
        //output "Span of subcurve: " + startX + " to " + endX + " for edge " + edgeNumber
    end

    action ResetCurrentYPosition()
        currentYPosition = yMinimum
    end

    action UpdateCurrentXPosition()
        currentYPosition = currentYPosition + 1
        //output "Update current x. current y is: " + currentYPosition + " and max y is: " + yMaximum
        if not isBezierCurve
            if slope not= 0 and not isVertical // not vertical and not horizontal
                if currentYPosition < yMaximum
                    currentXPosition = (currentYPosition - yIntercept) / slope
                    //output "CurrentXPosition: " + currentXPosition + ", startXPosition: " + startXPosition + ", endXPosition: " + endXPosition + " for edge # " + edgeNumber
                    if movingLeftToRight
                        if currentXPosition > endXPosition
                            currentXPosition = endXPosition
                        elseif currentXPosition < startXPosition
                            currentXPosition = startXPosition
                        end
                    else
                        if currentXPosition > startXPosition
                            currentXPosition = startXPosition
                        elseif currentXPosition < endXPosition
                            currentXPosition = endXPosition
                        end
                    end
                end
            end
        else    // bezier curve case
            //output "Bezier case."
            if currentYPosition < yMaximum
                FindBezierCurveXIntercepts()
                if movingLeftToRight
                    if currentXPosition > endXPosition
                        //output "Bezier x correction L->R > endX. currentX: " + currentXPosition + ", now set to: " + endXPosition
                        currentXPosition = endXPosition
                    elseif currentXPosition < startXPosition
                        //output "Bezier x correction L->R < startX. currentX: " + currentXPosition + ", now set to: " + startXPosition
                        currentXPosition = startXPosition
                    end
                else
                    if currentXPosition > startXPosition
                        //output "Bezier x correction R->L > startX. currentX: " + currentXPosition + ", now set to: " + startXPosition
                        currentXPosition = startXPosition
                    elseif currentXPosition < endXPosition
                        //output "Bezier x correction R->L > endX. currentX: " + currentXPosition + ", now set to: " + endXPosition
                        currentXPosition = endXPosition
                    end
                end
            end
            //output "After entering FindBezierCurveXIntercepts()"
        end
    end

    action GetMovingLeftToRight() returns boolean
        return movingLeftToRight
    end

    action GetSlope() returns number
        return slope
    end

    action GetYIntercept() returns number
        return yIntercept
    end

    action SetStartXPosition(number position)
        startXPosition = position
    end

    action SetStartYPosition(number position)
        startYPosition = position
    end

    action SetEndXPosition(number position)
        endXPosition = position
    end

    action SetEndYPosition(number position)
        endYPosition = position
    end

    action SetControlXPosition(number position)
        controlXPosition = position
    end

    action SetControlYPosition(number position)
        controlYPosition = position
    end

    action SetYMinimum(integer value)
        yMinimum = value
    end

    action SetYMaximum(integer value)
        yMaximum = value
    end

    action SetIsBezierCurve(boolean flag)
        isBezierCurve = flag
    end

    action SetIsAscending(boolean flag)
        isAscending = flag
    end

    action SetIsHorizontal(boolean flag)
        isHorizontal = flag
    end

    action GetStartXPosition() returns number
        return startXPosition
    end

    action GetStartYPosition() returns number
        return startYPosition
    end

    action GetEndXPosition() returns number
        return endXPosition
    end 

    action GetEndYPosition() returns number
        return endYPosition
    end

    action GetControlXPosition() returns number
        return controlXPosition
    end

    action GetControlYPosition() returns number
        return controlYPosition
    end

    action GetYMinimum() returns integer
        return yMinimum
    end

    action GetYMaximum() returns integer
        return yMaximum
    end

    action GetIsBezierCurve() returns boolean
        return isBezierCurve
    end

    action GetIsAscending() returns boolean
        return isAscending
    end

    action GetIsHorizontal() returns boolean
        return isHorizontal
    end 

    action GetScanlines() returns Array<integer>
        return scanlines
    end

    action GetScanlineIntercepts() returns Array<XIntercept>
        return scanlineIntercepts
    end

    // finds which y coordinates the edge intersects with
    action CalculateScanlines()
        number minimum = 0
        number maximum = 0
        number lowerThreshold = 0.25
        number upperThreshold = 0.75
        integer scanlinePosition = 0
        integer startYInteger = cast(integer, math:Floor(startYPosition))
        integer endYInteger = cast(integer, math:Floor(endYPosition))

        if isAscending  // line starts from lower y position and moves to higher one
            minimum = math:Round(startYPosition)
            maximum = math:Round(endYPosition)
        else        // line starts from higher y position and moves to lower one
            minimum = math:Round(endYPosition)
            maximum = math:Round(startYPosition)
        end

        yMinimum = cast(integer, minimum)
        yMaximum = cast(integer, maximum)
        scanlinePosition = cast(integer, minimum)
        //output "Ymin: " + yMinimum + ", YMax: " + yMaximum + ", scanlinePos: " + scanlinePosition

        repeat while scanlinePosition <= maximum
            scanlines:Add(scanlinePosition)

            scanlinePosition = scanlinePosition + 1
        end
        currentYPosition = yMinimum
        /*
        integer i = 0

        text t = ""
        repeat while i < scanlines:GetSize()
            t = t + ", " +  scanlines:Get(i)
        
            i = i + 1
        end
        output "This edge falls on the following scanlines: " + t
        */
    end

    // determines if the edge is ascending or descending
    action CalculateAscending()
        if startYPosition < endYPosition
            isAscending = true
            isHorizontal = false
        elseif startYPosition > endYPosition
            isAscending = false
            isHorizontal = false
        else    // horizontal case
            isAscending = false
            isHorizontal = true
        end
    end

    // sets the start x/y, end x/y and then if the edge is ascending, and finds scanlines that intersect it
    action CreateEdge(CoordinateVector startPoint, CoordinateVector endPoint, integer newEdgeNumber)
        startXPosition = startPoint:GetX()
        startYPosition = startPoint:GetY()
        endXPosition = endPoint:GetX()
        endYPosition = endPoint:GetY()
        edgeNumber = newEdgeNumber
        CalculateAscending()
        CalculateVertical()
        CalculateMovingLeftToRight()
        CalculateScanlines()
        CalculateSlopeAndYIntercept()   
        CalculateCurrentXPosition()
    end

    action CalculateIsYMonotonic()
        if startYPosition = controlYPosition and controlYPosition = endYPosition    // "flat" arc
            isYMonotonic = true
            isAscending = false
            isHorizontal = true
            isVertical = false
        elseif startYPosition <= controlYPosition and controlYPosition <= endYPosition  // ever-ascending arc
            isYMonotonic = true
            isAscending = true
            isHorizontal = false
            isVertical = false
        elseif startYPosition >= controlYPosition and controlYPosition >= endYPosition  // ever-descending arc
            isYMonotonic = true
            isAscending = false
            isHorizontal = false
            isVertical = false
        else    // non-monotonic arc
            isYMonotonic = false
        end
    end

    action CreateBezierEdge(CoordinateVector startPoint, CoordinateVector endPoint, CoordinateVector controlPoint, integer newEdgeNumber)
        startXPosition = startPoint:GetX()
        startYPosition = startPoint:GetY()
        endXPosition = endPoint:GetX()
        endYPosition = endPoint:GetY()
        controlXPosition = controlPoint:GetX()
        controlYPosition = controlPoint:GetY()
        edgeNumber = newEdgeNumber
        //output "Before monotonic"
        CalculateIsYMonotonic()
        //output "Before moving left to right"
        CalculateMovingLeftToRight()
        if isYMonotonic
            //output "Before scanlines"
            CalculateScanlines()
            //output "Before current x"
            CalculateCurrentXPosition()
            //output "Bezier done"
        end
    end

    // finds the intersection point on the edge for the given scanline
    action CalculateSlopeAndYIntercept()
        integer i = 0
        if not isHorizontal
            if not isVertical
                slope = (endYPosition-startYPosition)/(endXPosition-startXPosition)
            end
            yIntercept = startYPosition - slope * startXPosition
        end    
    end

    action CalculateVertical()
        if endXPosition - startXPosition = 0    // vertical line
            isVertical = true
        else
            isVertical = false
        end
    end

    action CalculateMovingLeftToRight()
        if startXPosition < endXPosition
            movingLeftToRight = true
        else
            movingLeftToRight = false
        end
    end
    
    action GetIsVertical() returns boolean
        return isVertical
    end
    
    action ToText()
        output "This edge begins at: (" + startXPosition + ", " + startYPosition + ") and ends at: (" + endXPosition + ", " + endYPosition + ")."
        output "It is ascending: " + isAscending
        output "It is vertical: " + isVertical
        output "It is horizontal: " + isHorizontal
        output "It spans from " + yMinimum + " to " + yMaximum + "."
    end
end