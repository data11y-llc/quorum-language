package Libraries.Game.Graphics.Fonts

use Libraries.Containers.Array
use Libraries.Compute.Math
use Libraries.Game.Graphics.Fonts.all
use Libraries.Language.Support.CompareResult

class GlyphOutlineEdge
    Math math
    Array<integer> scanlines
    Array<XIntercept> scanlineIntercepts
    number startXPosition = 0
    number startYPosition = 0
    number endXPosition = 0
    number endYPosition = 0
    number controlXPosition = 0
    number controlYPosition = 0
    integer yMinimum = 0
    integer yMaximum = 0
    boolean isBezierCurve = false
    boolean isAscending = false
    boolean isHorizontal = false
    boolean isVertical = false
    number slope = 0.0
    number yIntercept = 0.0
    boolean movingLeftToRight = false
    number currentXPosition = 0.0
    integer currentYPosition = 0
    integer edgeNumber = 0
    boolean isYMonotonic = false

    action GetEdgeNumber() returns integer
        return edgeNumber
    end

    // used to sort the active edge list by ascending x values
    action Compare(Object object) returns CompareResult
        CompareResult result
        if object is GlyphOutlineEdge
            GlyphOutlineEdge edge = cast(GlyphOutlineEdge, object)
            if currentXPosition > edge:GetCurrentXPosition()
                result:result = result:LARGER
            elseif currentXPosition < edge:GetCurrentXPosition()
                result:result = result:SMALLER
            else
                result:result = result:EQUAL
            end
            return result
        else
            return parent:Object:Compare(object)
        end
    end

    action GetCurrentXPosition() returns number
        return currentXPosition
    end

    action CalculateCurrentXPosition()
        // y = mx + b => (y-b)/m = x
        if not isBezierCurve
            if slope not= 0 and not isVertical // not vertical and not horizontal
                currentXPosition = (currentYPosition - yIntercept) / slope
            elseif isVertical
                currentXPosition = startXPosition
            // horizontal edges aren't processed
            end
        else    // bezier curve case
            // two ways: create two look-up tables and binary search the y values 
            // to find the intercept I need. This uses the weighted Bezier curve
            // formula. FreeType does not do it this way?
            // second way: FreeType subdivides the arc into smaller Bezier arcs
            // until the subdivision is too small to cross more than one span line
            // Need to think about pros and cons of both approaches and pick one
            // Not sure how you would find the x-intercept of an even smaller
            // Bezier curve without usiing the weighted formula?
        end
    end
    
    action UpdateCurrentXPosition()
        if slope not= 0 and not isVertical // not vertical and not horizontal
            currentYPosition = currentYPosition + 1
            if currentYPosition <= yMaximum
                currentXPosition = (currentYPosition - yIntercept) / slope
            end
        end
    end

    action GetMovingLeftToRight() returns boolean
        return movingLeftToRight
    end

    action GetSlope() returns number
        return slope
    end

    action GetYIntercept() returns number
        return yIntercept
    end

    action SetStartXPosition(number position)
        startXPosition = position
    end

    action SetStartYPosition(number position)
        startYPosition = position
    end

    action SetEndXPosition(number position)
        endXPosition = position
    end

    action SetEndYPosition(number position)
        endYPosition = position
    end

    action SetControlXPosition(number position)
        controlXPosition = position
    end

    action SetControlYPosition(number position)
        controlYPosition = position
    end

    action SetYMinimum(integer value)
        yMinimum = value
    end

    action SetYMaximum(integer value)
        yMaximum = value
    end

    action SetIsBezierCurve(boolean flag)
        isBezierCurve = flag
    end

    action SetIsAscending(boolean flag)
        isAscending = flag
    end

    action SetIsHorizontal(boolean flag)
        isHorizontal = flag
    end

    action GetStartXPosition() returns number
        return startXPosition
    end

    action GetStartYPosition() returns number
        return startYPosition
    end

    action GetEndXPosition() returns number
        return endXPosition
    end 

    action GetEndYPosition() returns number
        return endYPosition
    end

    action GetControlXPosition() returns number
        return controlXPosition
    end

    action GetControlYPosition() returns number
        return controlYPosition
    end

    action GetYMinimum() returns integer
        return yMinimum
    end

    action GetYMaximum() returns integer
        return yMaximum
    end

    action GetIsBezierCurve() returns boolean
        return isBezierCurve
    end

    action GetIsAscending() returns boolean
        return isAscending
    end

    action GetIsHorizontal() returns boolean
        return isHorizontal
    end 

    action GetScanlines() returns Array<integer>
        return scanlines
    end

    action GetScanlineIntercepts() returns Array<XIntercept>
        return scanlineIntercepts
    end

    // finds which y coordinates the edge intersects with
    action CalculateScanlines()
        number minimum = 0
        number maximum = 0
        number lowerThreshold = 0.25
        number upperThreshold = 0.75
        integer scanlinePosition = 0
        integer startYInteger = cast(integer, math:Floor(startYPosition))
        integer endYInteger = cast(integer, math:Floor(endYPosition))

        if isAscending  // line starts from lower y position and moves to higher one
            if startYPosition - startYInteger < upperThreshold
                minimum = startYInteger
            else
                minimum = startYInteger + 1
            end

            if endYPosition - endYInteger < lowerThreshold
                maximum = endYInteger - 1
            else
                maximum = endYInteger
            end
            minimum = math:Floor(startYPosition)
            maximum = math:Floor(endYPosition)
        else        // line starts from higher y position and moves to lower one
            if startYPosition - startYInteger < lowerThreshold
                maximum = startYInteger - 1
            else
                maximum = startYInteger
            end

            if endYPosition - endYInteger < upperThreshold
                minimum = endYInteger
            else    
                minimum = endYInteger + 1
            end
            minimum = math:Floor(endYPosition)
            maximum = math:Floor(startYPosition)
        end

        yMinimum = cast(integer, minimum)
        yMaximum = cast(integer, maximum)
        scanlinePosition = cast(integer, minimum)
        //output "Ymin: " + yMinimum + ", YMax: " + yMaximum + ", scanlinePos: " + scanlinePosition

        repeat while scanlinePosition <= maximum
            scanlines:Add(scanlinePosition)

            scanlinePosition = scanlinePosition + 1
        end
        currentYPosition = yMinimum
        /*
        integer i = 0

        text t = ""
        repeat while i < scanlines:GetSize()
            t = t + ", " +  scanlines:Get(i)
        
            i = i + 1
        end
        output "This edge falls on the following scanlines: " + t
        */
    end

    // determines if the edge is ascending or descending
    action CalculateAscending()
        if startYPosition < endYPosition
            isAscending = true
            isHorizontal = false
        elseif startYPosition > endYPosition
            isAscending = false
            isHorizontal = false
        else    // horizontal case
            isAscending = false
            isHorizontal = true
        end
    end

    // sets the start x/y, end x/y and then if the edge is ascending, and finds scanlines that intersect it
    action CreateEdge(CoordinateVector startPoint, CoordinateVector endPoint, integer newEdgeNumber)
        startXPosition = startPoint:GetX()
        startYPosition = startPoint:GetY()
        endXPosition = endPoint:GetX()
        endYPosition = endPoint:GetY()
        edgeNumber = newEdgeNumber
        CalculateAscending()
        CalculateVertical()
        CalculateMovingLeftToRight()
        CalculateScanlines()
        CalculateSlopeAndYIntercept()   
        CalculateCurrentXPosition()
    end

    action CalculateIsYMonotonic()
        if startYPosition = controlYPosition and controlYPosition = endYPosition    // "flat" arc
            isYMonotonic = true
            isAscending = false
            isHorizontal = true
            isVertical = false
        elseif startYPosition <= controlYPosition and controlYPosition <= endYPosition  // ever-ascending arc
            isYMonotonic = true
            isAscending = true
            isHorizontal = false
            isVertical = false
        elseif startYPosition >= controlYPosition and controlYPosition >= endYPosition  // ever-descending arc
            isYMonotonic = true
            isAscending = false
            isHorizontal = false
            isVertical = false
        else    // non-monotonic arc
            isYMonotonic = false
        end
    end

    action CreateBezierEdge(CoordinateVector startPoint, CoordinateVector endPoint, CoordinateVector controlPoint, integer newEdgeNumber)
        startXPosition = startPoint:GetX()
        startYPosition = startPoint:GetY()
        endXPosition = endPoint:GetX()
        endYPosition = endPoint:GetY()
        controlXPosition = controlPoint:GetX()
        controlYPosition = controlPoint:GetY()
        edgeNumber = newEdgeNumber
        CalculateIsYMonotonic()
        CalculateMovingLeftToRight()
        if isYMonotonic
            CalculateScanlines()
            CalculateCurrentXPosition()
        end
    end

    // finds the intersection point on the edge for the given scanline
    action CalculateSlopeAndYIntercept()
        integer i = 0
        if not isHorizontal
            if not isVertical
                slope = (endYPosition-startYPosition)/(endXPosition-startXPosition)
            end
            yIntercept = startYPosition - slope * startXPosition
            /*
            repeat while i < scanlines:GetSize()
                XIntercept x
                number intercept = 0.0
                integer y = scanlines:Get(i)
                x:SetYPosition(y)
                if isVertical   // straight up and down line, it intersects it at the x value
                    intercept = startXPosition
                elseif isHorizontal // horizontal line, slope = 0. need to handle these specially

                else // some kind of slanted line, use linear equation to solve for x
                    intercept = (y-yIntercept)/slope
                end
                x:SetXIntercept(intercept)

                scanlineIntercepts:Add(x)

                output "For scanline " + y + " the x intercept is: " + intercept

                i = i + 1
            end
            */
        end    
    end

    action CalculateVertical()
        if endXPosition - startXPosition = 0    // vertical line
            isVertical = true
        else
            isVertical = false
        end
    end

    action CalculateMovingLeftToRight()
        if startXPosition < endXPosition
            movingLeftToRight = true
        else
            movingLeftToRight = false
        end
    end
    
    action GetIsVertical() returns boolean
        return isVertical
    end
    
    action ToText()
        output "This edge begins at: (" + startXPosition + ", " + startYPosition + ") and ends at: (" + endXPosition + ", " + endYPosition + ")."
        output "It is ascending: " + isAscending
        output "It is vertical: " + isVertical
        output "It is horizontal: " + isHorizontal
        output "It spans from " + yMinimum + " to " + yMaximum + "."
    end
end