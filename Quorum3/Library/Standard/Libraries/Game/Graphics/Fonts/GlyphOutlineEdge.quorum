package Libraries.Game.Graphics.Fonts

use Libraries.Containers.Array
use Libraries.Compute.Math
use Libraries.Game.Graphics.Fonts.all
use Libraries.Language.Support.CompareResult

class GlyphOutlineEdge
    Math math
    Array<integer> scanlines
    Array<GlyphOutlineEdge> splitEdges
    Array<XIntercept> scanlineIntercepts
    Array<number> bezierCurveYIntercepts
    Array<number> xIntercepts
    number startXPosition = 0
    number startYPosition = 0
    number endXPosition = 0
    number endYPosition = 0
    number controlXPosition = 0
    number controlYPosition = 0
    integer yMinimum = 0
    integer yMaximum = 0
    boolean isBezierCurve = false
    boolean isAscending = false
    boolean isHorizontal = false
    boolean isVertical = false
    number slope = 0.0
    number yIntercept = 0.0
    boolean movingLeftToRight = false
    number currentXPosition = 0.0
    number currentStartXPosition = 0.0
    number currentEndXPosition = 0.0
    integer currentYPosition = 0
    integer yIndex = 0
    integer edgeNumber = 0
    boolean isYMonotonic = false
    number subEdgeStartX = 0.0
    number subEdgeStartY = 0.0
    number subEdgeEndX = 0.0
    number subEdgeEndY = 0.0
    number subEdgeControlX = 0.0
    number subEdgeControlY = 0.0

    action SetCurrentXPosition(number position)
        currentXPosition = position
    end

    action SetSplitEdgeArray(Array<GlyphOutlineEdge> edges)
        splitEdges = edges:CopyToArray()
    end

    action GetSplitEdgeArray() returns Array<GlyphOutlineEdge>
        return splitEdges
    end

    action GetCurrentStartXPosition() returns number
        return currentStartXPosition
    end

    action GetCurrentEndXPosition() returns number
        return currentEndXPosition
    end

    action GetSubEdgeStartX() returns number
        return subEdgeStartX
    end

    action GetSubEdgeStartY() returns number
        return subEdgeStartY
    end

    action GetSubEdgeEndX() returns number
        return subEdgeEndX
    end

    action GetSubEdgeEndY() returns number
        return subEdgeEndY
    end

    action GetBezierCurveYIntercepts() returns Array<number>
        return bezierCurveYIntercepts
    end

    action GetEdgeNumber() returns integer
        return edgeNumber
    end

    action GetIsYMonotonic() returns boolean
        return isYMonotonic
    end

    // used to sort the active edge list by ascending x values
    action Compare(Object object) returns CompareResult
        CompareResult result
        if object is GlyphOutlineEdge
            GlyphOutlineEdge edge = cast(GlyphOutlineEdge, object)
            if currentXPosition > edge:GetCurrentXPosition()
                result:result = result:LARGER
            elseif currentXPosition < edge:GetCurrentXPosition()
                result:result = result:SMALLER
            else
                result:result = result:EQUAL
            end
            return result
        else
            return parent:Object:Compare(object)
        end
    end

    action GetCurrentXPosition() returns number
        return currentXPosition
    end

    action CalculateCurrentXPosition()
        // y = mx + b => (y-b)/m = x
        if not isBezierCurve
            if slope not= 0 and not isVertical // not vertical and not horizontal
                currentXPosition = (currentYPosition - yIntercept) / slope
                if movingLeftToRight
                    if currentXPosition > endXPosition
                        currentXPosition = endXPosition
                    elseif currentXPosition < startXPosition
                        currentXPosition = startXPosition
                    end
                else
                    if currentXPosition > startXPosition
                        currentXPosition = startXPosition
                    elseif currentXPosition < endXPosition
                        currentXPosition = endXPosition
                    end
                end
            elseif isVertical
                currentXPosition = startXPosition
            // horizontal edges aren't processed
            end
        else    // bezier curve case
            // two ways: create two look-up tables and binary search the y values 
            // to find the intercept I need. This uses the weighted Bezier curve
            // formula. FreeType does not do it this way?
            // second way: FreeType subdivides the arc into smaller Bezier arcs
            // until the subdivision is too small to cross more than one span line
            // Need to think about pros and cons of both approaches and pick one
            // Not sure how you would find the x-intercept of an even smaller
            // Bezier curve without usiing the weighted formula?
            
            //FindBezierCurveXIntercepts()

        end
    end

    action ResetCurrentYPosition()
        currentYPosition = yMinimum
    end

    action UpdateCurrentXPosition()
        currentYPosition = currentYPosition + 1
        yIndex = yIndex + 1
        //output "Update current x. current y is: " + currentYPosition + " and max y is: " + yMaximum
        if not isBezierCurve
            if slope not= 0 and not isVertical // not vertical and not horizontal
                if currentYPosition < yMaximum
                    currentXPosition = (currentYPosition - yIntercept) / slope
                    //output "CurrentXPosition: " + currentXPosition + ", startXPosition: " + startXPosition + ", endXPosition: " + endXPosition + " for edge # " + edgeNumber
                    if movingLeftToRight
                        if currentXPosition > endXPosition
                            currentXPosition = endXPosition
                        elseif currentXPosition < startXPosition
                            currentXPosition = startXPosition
                        end
                    else
                        if currentXPosition > startXPosition
                            currentXPosition = startXPosition
                        elseif currentXPosition < endXPosition
                            currentXPosition = endXPosition
                        end
                    end
                end
            end
        else    // bezier curve case
            //output "Bezier case."
            if currentYPosition < yMaximum
                currentXPosition = xIntercepts:Get(yIndex)
            end
            //output "After entering FindBezierCurveXIntercepts()"
        end
    end

    action GetMovingLeftToRight() returns boolean
        return movingLeftToRight
    end

    action GetSlope() returns number
        return slope
    end

    action GetYIntercept() returns number
        return yIntercept
    end

    action SetStartXPosition(number position)
        startXPosition = position
    end

    action SetStartYPosition(number position)
        startYPosition = position
    end

    action SetEndXPosition(number position)
        endXPosition = position
    end

    action SetEndYPosition(number position)
        endYPosition = position
    end

    action SetControlXPosition(number position)
        controlXPosition = position
    end

    action SetControlYPosition(number position)
        controlYPosition = position
    end

    action SetYMinimum(integer value)
        yMinimum = value
    end

    action SetYMaximum(integer value)
        yMaximum = value
    end

    action SetIsBezierCurve(boolean flag)
        isBezierCurve = flag
    end

    action SetIsAscending(boolean flag)
        isAscending = flag
    end

    action SetIsHorizontal(boolean flag)
        isHorizontal = flag
    end

    action GetStartXPosition() returns number
        return startXPosition
    end

    action GetStartYPosition() returns number
        return startYPosition
    end

    action GetEndXPosition() returns number
        return endXPosition
    end 

    action GetEndYPosition() returns number
        return endYPosition
    end

    action GetControlXPosition() returns number
        return controlXPosition
    end

    action GetControlYPosition() returns number
        return controlYPosition
    end

    action GetYMinimum() returns integer
        return yMinimum
    end

    action GetYMaximum() returns integer
        return yMaximum
    end

    action GetIsBezierCurve() returns boolean
        return isBezierCurve
    end

    action GetIsAscending() returns boolean
        return isAscending
    end

    action GetIsHorizontal() returns boolean
        return isHorizontal
    end 

    action GetScanlines() returns Array<integer>
        return scanlines
    end

    action GetScanlineIntercepts() returns Array<XIntercept>
        return scanlineIntercepts
    end

    // finds which y coordinates the edge intersects with
    action CalculateScanlines()
        number minimum = 0
        number maximum = 0
        number lowerThreshold = 0.25
        number upperThreshold = 0.75
        integer scanlinePosition = 0
        integer startYInteger = cast(integer, math:Floor(startYPosition))
        integer endYInteger = cast(integer, math:Floor(endYPosition))

        if isAscending  // line starts from lower y position and moves to higher one
            minimum = math:Round(startYPosition)
            maximum = math:Round(endYPosition)
        else        // line starts from higher y position and moves to lower one
            minimum = math:Round(endYPosition)
            maximum = math:Round(startYPosition)
        end

        yMinimum = cast(integer, minimum)
        yMaximum = cast(integer, maximum)
        scanlinePosition = cast(integer, minimum)
        //output "Ymin: " + yMinimum + ", YMax: " + yMaximum + ", scanlinePos: " + scanlinePosition

        repeat while scanlinePosition <= maximum
            scanlines:Add(scanlinePosition)

            scanlinePosition = scanlinePosition + 1
        end
        currentYPosition = yMinimum
        /*
        integer i = 0

        text t = ""
        repeat while i < scanlines:GetSize()
            t = t + ", " +  scanlines:Get(i)
        
            i = i + 1
        end
        output "This edge falls on the following scanlines: " + t
        */
    end

    // determines if the edge is ascending or descending
    action CalculateAscending()
        if startYPosition < endYPosition
            isAscending = true
            isHorizontal = false
        elseif startYPosition > endYPosition
            isAscending = false
            isHorizontal = false
        else    // horizontal case
            isAscending = false
            isHorizontal = true
        end
    end

    // sets the start x/y, end x/y and then if the edge is ascending, and finds scanlines that intersect it
    action CreateEdge(CoordinateVector startPoint, CoordinateVector endPoint, integer newEdgeNumber)
        startXPosition = startPoint:GetX()
        startYPosition = startPoint:GetY()
        endXPosition = endPoint:GetX()
        endYPosition = endPoint:GetY()
        edgeNumber = newEdgeNumber
        CalculateAscending()
        CalculateVertical()
        CalculateMovingLeftToRight()
        CalculateScanlines()
        CalculateSlopeAndYIntercept()   
        CalculateCurrentXPosition()
    end

    action CalculateIsYMonotonic()
        if startYPosition = controlYPosition and controlYPosition = endYPosition    // "flat" arc
            isYMonotonic = true
            isAscending = false
            isHorizontal = true
            isVertical = false
        elseif startYPosition <= controlYPosition and controlYPosition <= endYPosition  // ever-ascending arc
            isYMonotonic = true
            isAscending = true
            isHorizontal = false
            isVertical = false
        elseif startYPosition >= controlYPosition and controlYPosition >= endYPosition  // ever-descending arc
            isYMonotonic = true
            isAscending = false
            isHorizontal = false
            isVertical = false
        else    // non-monotonic arc
            isYMonotonic = false
        end
    end

    action CreateBezierEdge(CoordinateVector startPoint, CoordinateVector endPoint, CoordinateVector controlPoint, integer newEdgeNumber)
        startXPosition = startPoint:GetX()
        startYPosition = startPoint:GetY()
        endXPosition = endPoint:GetX()
        endYPosition = endPoint:GetY()
        controlXPosition = controlPoint:GetX()
        controlYPosition = controlPoint:GetY()
        //output "New Bezier. start, control, end y: " + startYPosition + ", " + controlYPosition + ", " + endYPosition
        edgeNumber = newEdgeNumber
        //output "Before monotonic"
        CalculateIsYMonotonic()
        //output "Before moving left to right"
        CalculateMovingLeftToRight()
        if isYMonotonic
            //output "Before scanlines"
            CalculateScanlines()
            SplitIntoSubArcs(me)
            //output "Before current x"
            //CalculateCurrentXPosition()
            //output "Bezier done"
        else
            //output "Not y monotonic. Something is wrong"
        end
    end

    action FindXIntercepts()
        // This should find and store every x intercept for this scanline, in ascending order
        // Stored in the xIntercepts array of numbers
        //output "Finding x intercepts for edge #" + edgeNumber + " which runs from (" + startXPosition + ", " + startYPosition + ") to (" + endXPosition + ", " + endYPosition + ")."
        // initialize xIntercepts array so this can be done in a single iteration
        integer i = yMinimum
        repeat while i <= yMaximum
            if isAscending  // we want the right-most x-coordinates for each edge so initialize to a small number
                xIntercepts:Add(-9999)
            else            // we want the left-most x-coordinates for each edge so initialize to a large number
                xIntercepts:Add(9999)
            end

            i = i + 1
        end

        i = yMinimum
        integer index = 0
        repeat while i <= yMaximum
            integer j = 0
            repeat while j < splitEdges:GetSize()
                GlyphOutlineEdge edge = splitEdges:Get(j)
                number startX = edge:GetStartXPosition()
                number startY = math:Round(edge:GetStartYPosition())
                number endX = edge:GetEndXPosition()
                number endY = math:Round(edge:GetEndYPosition())
                //output "split startX: " + startX + " endX: " + endX + " startY: " + startY + " endY: " + endY + " scanline: " + i
                if i >= startY and i <= endY or i <= startY and i >= endY   // split falls on the current scanline
                    if isAscending
                        if movingLeftToRight  // use the end x value
                            if endX > xIntercepts:Get(index)
                                xIntercepts:Set(index, endX)
                            end
                        else    // use the start x value
                            if startX > xIntercepts:Get(index)
                                xIntercepts:Set(index, startX)
                            end
                        end
                    else
                        if movingLeftToRight  // use the start x value
                            if startX < xIntercepts:Get(index)
                                xIntercepts:Set(index, startX)
                            end
                        else    // use the end x value
                            if endX < xIntercepts:Get(index)
                                xIntercepts:Set(index, endX)
                            end
                        end
                    end
                end
                
                j = j + 1
            end
            index = index + 1
            i = i + 1
        end
        
        /*
        i = 0
        integer scanline = yMinimum
        repeat while i < xIntercepts:GetSize()
            output "X intercept for scanline " + scanline + " is: " + xIntercepts:Get(i)
            scanline = scanline + 1
            i = i + 1
        end
        */
        currentXPosition = xIntercepts:Get(0)

    end

    private action SplitIntoSubArcs(GlyphOutlineEdge edge)
        //output "Edge splitting. Stats for " + edge:GetEdgeNumber() + " are:"
        //edge:ToText()
        number Q1x = 0.0
        number Q1y = 0.0
        number Q2x = 0.0
        number Q2y = 0.0
        number Q3x = 0.0
        number Q3y = 0.0
        number R1x = 0.0
        number R1y = 0.0
        number R2x = 0.0
        number R2y = 0.0
        number R3x = 0.0
        number R3y = 0.0
        number P1x = edge:GetStartXPosition()
        number P1y = edge:GetStartYPosition()
        number P2x = edge:GetControlXPosition()
        number P2y = edge:GetControlYPosition()
        number P3x = edge:GetEndXPosition()
        number P3y = edge:GetEndYPosition()

        if math:AbsoluteValue(P1y - P3y) < 1
            CoordinateVector startPoints
            CoordinateVector endPoints
            GlyphOutlineEdge newEdge
            startPoints:SetX(edge:GetStartXPosition())
            startPoints:SetY(edge:GetStartYPosition())
            endPoints:SetX(edge:GetEndXPosition())
            endPoints:SetY(edge:GetEndYPosition())
            newEdge:CreateEdge(startPoints, endPoints, edge:GetEdgeNumber())
            splitEdges:Add(newEdge)
        else
            // Edge not small enough, continue subdivision
            Q1x = P1x
            Q1y = P1y
            Q2x = (P1x + P2x)/2
            Q2y = (P1y + P2y)/2
            R3x = P3x
            R3y = P3y
            R2x = (P2x + P3x)/2
            R2y = (P2y + P3y)/2
            Q3x = (Q2x + R2x)/2
            Q3y = (Q2y + R2y)/2
            R1x = Q3x
            R1y = Q3y

            GlyphOutlineEdge edge1
            GlyphOutlineEdge edge2
            CoordinateVector start
            CoordinateVector control
            CoordinateVector ending

            start:SetX(Q1x)
            start:SetY(Q1y)
            control:SetX(Q2x)
            control:SetY(Q2y)
            ending:SetX(Q3x)
            ending:SetY(Q3y)

            edge1:CreateBezierEdge(start, ending, control, -edge:GetEdgeNumber())

            start:SetX(R1x)
            start:SetY(R1y)
            control:SetX(R2x)
            control:SetY(R2y)
            ending:SetX(R3x)
            ending:SetY(R3y)

            edge2:CreateBezierEdge(start, ending, control, -edge:GetEdgeNumber())

            SplitIntoSubArcs(edge1)
            SplitIntoSubArcs(edge2)
        end
    end

    // finds the intersection point on the edge for the given scanline
    action CalculateSlopeAndYIntercept()
        integer i = 0
        if not isHorizontal
            if not isVertical
                slope = (endYPosition-startYPosition)/(endXPosition-startXPosition)
            end
            yIntercept = startYPosition - slope * startXPosition
        end    
    end

    action CalculateVertical()
        if endXPosition - startXPosition = 0    // vertical line
            isVertical = true
        else
            isVertical = false
        end
    end

    action CalculateMovingLeftToRight()
        if startXPosition < endXPosition
            movingLeftToRight = true
        else
            movingLeftToRight = false
        end
    end
    
    action GetIsVertical() returns boolean
        return isVertical
    end
    
    action ToText()
        output "This edge begins at: (" + startXPosition + ", " + startYPosition + ") and ends at: (" + endXPosition + ", " + endYPosition + ")."
        //output "It is ascending: " + isAscending
        //output "It is vertical: " + isVertical
        //output "It is horizontal: " + isHorizontal
        output "It spans from " + yMinimum + " to " + yMaximum + "."
    end
end