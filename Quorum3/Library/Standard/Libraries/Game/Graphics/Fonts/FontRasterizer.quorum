package Libraries.Game.Graphics.Fonts

use Libraries.Game.Game
use Libraries.Game.Graphics.PixelMap
use Libraries.Game.Graphics.Fonts.all
use Libraries.Containers.Array
use Libraries.System.File
use Libraries.Game.Graphics.Format
use Libraries.Game.Graphics.Texture
use Libraries.Game.Graphics.Drawable
use Libraries.Game.Graphics.Color
use Libraries.Game.ScreenResolution
use Libraries.Compute.Math
use Libraries.Game.Graphics.Camera
use Libraries.Game.Graphics.Label
use Libraries.Game.Graphics.Font
use Libraries.Containers.List
use Libraries.Interface.Item2D
use Libraries.Compute.BitwiseOperations
use Libraries.Game.Graphics.Blending
use Libraries.Language.Support.CompareResult
use Libraries.Containers.HashTable
use Libraries.Game.Graphics.Fonts.GlyphOutlineEdge

/*
This is the main testing file for the new rasterizer. It follows the general
process as outlined in the FreeType rasterization.txt file that I linked in my
Font file under the Resources section. This file should make testing the rasterizer
fast and easy, as well as make sure it hits all the marks to see if anything is
broken. Once the rasterizer is working, I suggest adopting the click-to-cycle system 
I have in the FontVisualTester file from the Font Testing project on this same
repository. This allows you to quickly and easily check every font file on the
system. I have left it out for now because it only makes this more cumbersome
while working on it, and it isn't necessary to test all font files when  it is
still fundamentally wrong.

I strongly recommend you do all your work here since it eliminates the constant
bootstrapping hassle of making changes in the standard library. 

        *****READ THE RASTERIZATION.TXT FILE AND UNDERSTAND IT*****
*/
class FontRasterizer
    integer emSize = 2048
    integer pixelSize = 14
    // The lowest y-value (scanline) this glyph has
    integer scanlineMaximum = -99999999
    // The highest y-value this glyph has
    integer scanlineMinimum = 99999999
    // The left-most x-value of the glyph (used for the pixelmap)
    integer xMinimum = 999999999
    // The right-most x-value of the glyph (used for the pixelmap)
    integer xMaximum = -999999999
    // The width of the glyph in pixels
    integer glyphWidth = 0
    // The height of the glyph in pixels
    integer glyphHeight = 0
    // This array stores the edges making up a glyph
    Array<GlyphOutlineEdge> edges
    // Math is used everywhere, class variable for easy access
    Math math
    // Color is used when drawing the outline and filling it in, used in many spots
    // so a class variable makes it easier. Useful to change this to other colors
    // to test things out
    //Color color
    // Width of the game window to create
    screenXSize = 1400
    // Height of the game window to create
    screenYSize = 900
    // Font size to use, make sure you test lots of sizes to see if it works right
    // I would not go below size 10, personally, since it needs hinting to really
    // work. 


    /*
    The algorithm relies on the edges being in two categories: opening and closing
    or left and right respectively. These lists store the edges that are still
    active in the algorithm process, meaning during the scanning process, the edge
    has a y-value corresponding to the current scanline. Once the scanline extends
    beyond the highest y-value of an edge, the edge is removed from these lists.
    */
    List<GlyphOutlineEdge> activeEdgeListLeft
    List<GlyphOutlineEdge> activeEdgeListRight

    /*
    An array of arrays...Basically, for every y-value the glyph covers, there is
    a "bucket" for the y-value. Each of these y-values/scanlines is associated
    with an array of GlyphOutlineEdge. The association is as such: if an edge
    starts on y = 0, then scanlineBuckets[0] gets this edge array.
    */
    Array<Array<GlyphOutlineEdge>> scanlineBuckets

    /*
    This is the Bezier curve anti-alias action. The approach used is grid-based
    super sampling, which you can google but I will explain briefly here.

    The idea is you take a pixel, subdivide it into smaller sections, and then
    for each of these sections you see if the edge falls within the sub-pixel.
    If it does, you add it to a running sum of coverage for the pixel, and if
    it doesn't you don't add anything. Once you check every subpixel, you divide
    the total covered by the total subpixels, and this gives you the pixel coverage
    When using a value of 256, we can get 256 different shades of gray and color
    an outline appropriately.

    I *think* this is finally correct, but you should definitely look through it
    and see if you can improve it or find problems with it. Additionally, it would
    be nice to make it so straight lines use this same action instead of its own
    as it currently does, although I don't think it is necessary as straight lines
    seem to be good.
    */
    action TestCoverage(PixelMap pixelMap, GlyphOutlineEdge edge)
        number startX = edge:GetStartXPosition()
        number startY = edge:GetStartYPosition()
        number endX = edge:GetEndXPosition()
        number endY = edge:GetEndYPosition()
        number slope = (endY - startY)/(endX - startX)
        number yIntercept = startY - slope * startX
        number minX = startX
        number maxX = endX
        number minY = startY
        number maxY = endY
        integer height = pixelMap:GetHeight() - 1
        boolean movingLeftToRight = true
        boolean ascending = true
        Color color
        

        // You can adjust this if you'd like, but FreeType uses 256 shades of gray
        // To me, 64 looks just as good and is a lot better performance-wise
        // This is the number of sub-pixels to divide a pixel into
        number sampleSize = 256
        // The number of subpixels in a row/column
        number squareRootSampleSize = math:SquareRoot(sampleSize)
        // We want to move along the x and y axes one sub-pixel at a time, so
        // this is the increment for that
        number sampleIncrement = 1/squareRootSampleSize
        // Stores the current color value of the pixel
        number currentPixelValue = 0
        // The number of subpixels covered by the edge
        integer subPixelsCovered = 0
        // Start scanning at the lowest y-value of the edge
        number currentY = startY
        // Stop scanning at the highest y-value of the edge
        number yScanBoundary = endY
        
        // for moving right to left, swap values
        if minX > maxX
            minX = endX
            maxX = startX
            movingLeftToRight = false
        end

        // For descending, swap values
        if minY > maxY
            minY = endY
            maxY = startY
            ascending = false
        end

        currentY = minY
        yScanBoundary = maxY

        /*
        This sets the end-point for scanning along the x-axis. For ascending lines,
        which indicate to begin filling a glyph in, we want the highest x-value
        on the edge. For descending lines, which indicate to end filling a glyph
        in, we want the lowest x-value on the edge.
        
        Again, possible rounding problems here. It's also possible that this is
        wrong in the same way that the xIntercept calculation is wrong, where it
        always uses the same value instead of calculates one for each scanline.
        */
        integer xScanBoundary = 0
        if ascending and movingLeftToRight
            xScanBoundary = cast(integer, math:Ceiling(endX))
        elseif ascending and not movingLeftToRight
            xScanBoundary = cast(integer, math:Ceiling(startX))
        elseif not ascending and movingLeftToRight
            xScanBoundary = cast(integer, math:Floor(startX))
        elseif not ascending and not movingLeftToRight
            xScanBoundary = cast(integer, math:Floor(endX))
        end

        currentY = minY

        // Algorithm outline:
        // iterate from the lowest y value to the highest y value (yScanBoundary), increasing using sample increment (currentY)
        // calculate x intercept of the line at each y-sample: x = (y - b) / m
            // make sure the x-value is bounded by the start/end x position
        // iterate from calculated x-position to xScanBoundary
        // add the  number of x-samples covered for each x/y pixel position to the corresponding pixel
        // i.e. ascending left to right line:
            // ((ceiling(currentX) - currentX) * squareRootSampleSize) / sampleSize for first x pixel
            // squareRootSampleSize/sampleSize for subsequent pixels

        // Start from the lowest y-value this edge covers, and continue until it
        // reaches the highest y-value the edge covers.
        repeat while currentY < yScanBoundary
            number currentX = (currentY - yIntercept) / slope
            // ascending cases
            // general note: as lines are continuous and one line begins where another ends
            // there is currently double counting going on at the start/endpoints of lines
            // this might partially explain some of the black between the gray values
            // although there is definitely a problem with adding to the alpha values
            if ascending
                // gets the current color of the given pixel and sets color to it
                integer colorCode = pixelMap:GetPixel(cast(integer, currentX) - xMinimum, height - cast(integer, currentY) + scanlineMinimum)
                color:SetColorFromCode(colorCode)
                // Instead of iterating over x until I hit the boundary, I do a simple calculate
                // Find the difference betwen the current x and the next x and multiply
                // it by how many columns there are.
                number additionalValue = ((math:Floor(currentX + 1) - currentX) * squareRootSampleSize) / sampleSize
                // adds the new coverage value to the old
                color:SetAlpha(additionalValue + color:GetAlpha())
                // sets the pixel to the new color
                pixelMap:SetPixel(cast(integer, currentX) - xMinimum, height - cast(integer, currentY) + scanlineMinimum, color)
                // move to the next x-value along the edge
                currentX = math:Floor(currentX + 1)
                // repeat the above process until it gets to the end of the line
                repeat while currentX < xScanBoundary
                    colorCode = pixelMap:GetPixel(cast(integer, currentX) - xMinimum, height - cast(integer, currentY) + scanlineMinimum)
                    color:SetColorFromCode(colorCode)
                    additionalValue = squareRootSampleSize/sampleSize
                    color:SetAlpha(additionalValue + color:GetAlpha())
                    pixelMap:SetPixel(cast(integer, currentX) - xMinimum, height - cast(integer, currentY) + scanlineMinimum, color)
                    currentX = currentX + 1
                end
            else
            // The descending case is more or less the same as the ascending case
            // I did not test this as much, and I have not thoroughly worked through
            // it on paper, so it is very possible that this is slightly off, but
            // it seems close nonetheless.
                integer colorCode = pixelMap:GetPixel(cast(integer, currentX) - xMinimum, height - cast(integer, currentY) + scanlineMinimum)
                color:SetColorFromCode(colorCode)
                number additionalValue = ((currentX - math:Ceiling(currentX - 1)) * squareRootSampleSize) / sampleSize
                color:SetAlpha(additionalValue + color:GetAlpha())
                pixelMap:SetPixel(cast(integer, currentX) - xMinimum, height - cast(integer, currentY) + scanlineMinimum, color)
                currentX = math:Ceiling(currentX - 1)
                repeat while xScanBoundary < currentX
                    colorCode = pixelMap:GetPixel(cast(integer, xScanBoundary) - xMinimum, height - cast(integer, currentY) + scanlineMinimum)
                    color:SetColorFromCode(colorCode)
                    additionalValue = squareRootSampleSize/sampleSize
                    color:SetAlpha(additionalValue + color:GetAlpha())
                    pixelMap:SetPixel(cast(integer, xScanBoundary) - xMinimum, height - cast(integer, currentY) + scanlineMinimum, color)

                    xScanBoundary = xScanBoundary + 1
                end
            end

            // move on to the next y sub-pixel
            currentY = currentY + sampleIncrement
        end
    end

    /*
    This action really just loops over the sub-divided Bezier curve edges
    and sends them to the anti-alias function. This should definitely be cleaned up
    eventually.
    */
    action TestAntiAlias(PixelMap pixelMap)
        integer i = 0
        integer height = pixelMap:GetHeight() - 1

        repeat while i < edges:GetSize()
            GlyphOutlineEdge edge = edges:Get(i)
            if edge:GetIsBezierCurve()
                integer j = 0
                Array<GlyphOutlineEdge> splits = edge:GetSplitEdgeArray()

                repeat while j < splits:GetSize()
                    GlyphOutlineEdge split = splits:Get(j)
                    TestCoverage(pixelMap, split)
                    j = j + 1
                end
            else
                /*
                At some point you should consider handling straight lines here.
                That anti-aliasing is currently done elsewhere, and I'm 99.9%
                sure that it's working correctly. So it's not urgent, it would
                just be nice to have it in one method so the code is cleaner.
                */
            end

            i = i + 1
        end
    end

    /*
    This action finds the width and height of a glyph. Used to make the optimal
    size pixelmap. It's 1-2 pixels taller than needed due to needing extra space
    for the scale.
    */
    action FindGlyphWidthAndHeight(BezierCurveGlyphPoints glyphPoints)
        Array<CoordinateVector> coordinates = glyphPoints:GetPoints()
        number x = 0
        number y = 0
        CoordinateVector vector
        integer i = 0

        repeat while i < coordinates:GetSize()
            vector = coordinates:Get(i)
            x = vector:GetX()
            y = vector:GetY()

            if x < xMinimum
                xMinimum = cast(integer, math:Floor(x))
            end

            if x > xMaximum
                xMaximum = cast(integer, math:Ceiling(x))
            end

            if y < scanlineMinimum
                scanlineMinimum = cast(integer, math:Floor(y))
            end

            if y > scanlineMaximum
                scanlineMaximum = cast(integer, math:Ceiling(y))
            end

            i = i + 1
        end

        me:glyphHeight = scanlineMaximum - scanlineMinimum + 1
        me:glyphWidth = xMaximum - xMinimum + 1
    end

    /* Debugging action:
    This action draws the vertices of the edges onto the pixel map. Set the color
    to something that is not the same as the fill/outline color to see them.
    Not super useful, but you may find a need for it eventually. Note that
    when using this on Bezier curves you will see points that are quite far from
    the glyph; these are control points and are normal.
    */
    action DrawEdgeVertices(PixelMap pixelMap)
        Color color
        integer i = 0
        repeat while i < edges:GetSize()
            GlyphOutlineEdge edge = edges:Get(i)
            pixelMap:SetPixel(cast(integer, math:Floor(edge:GetStartXPosition()))-xMinimum, pixelMap:GetHeight() - 1 - cast(integer, math:Floor(edge:GetStartYPosition()))+scanlineMinimum, color:Red())
            pixelMap:SetPixel(cast(integer, math:Floor(edge:GetEndXPosition()))-xMinimum, pixelMap:GetHeight() - 1 - cast(integer, math:Floor(edge:GetEndYPosition()))+scanlineMinimum, color:Red())
            
            if edge:GetIsBezierCurve()
                pixelMap:SetPixel(cast(integer, math:Floor(edge:GetControlXPosition()))-xMinimum, pixelMap:GetHeight() - 1 - cast(integer, math:Floor(edge:GetControlYPosition()))+scanlineMinimum, color:Blue())
            end

            i = i + 1
        end
    end

    // This action draws a pixel scal on the pixelmap. Used for debugging so
    // you can pinpoint where problems are happening. Draws a checkerboard pettern
    // at the top and on the right side of the pixelmap.
    action DrawScale(PixelMap pixelMap)
        Color color
        integer i = 0
        integer height = pixelMap:GetHeight() - 1
        integer width = pixelMap:GetWidth()

        repeat while i <= scanlineMaximum
            pixelMap:SetPixel(xMaximum-xMinimum, height - i, color:Black())

            i = i + 2
        end

        i = 0
        repeat while i <= xMaximum + 1
            pixelMap:SetPixel(i-xMinimum, height - scanlineMaximum  + scanlineMinimum, color:Black())

            i = i + 2
        end
    end
    
    /*
    This action is the main loop for filling a glyph in. It follows the process
    detailed in the rasterization.txt file I reference in my Font file under the
    Resources section. They do a much better job of explaining it than I do, so
    I will only provide a brief explanation of the process:
    
    - Loop from low y to max y
    - Get all edges that begin on the current scanline
    - Add these edges to the active edge list
    - Remove edges from the active edge list if they are no longer covered by the scanline
    - Fill in between edges on the current scanline
    - Update the current x-position of all active edges
    - Sort the active edge list in ascending x-value order

    See individual action documentation for each action's specific details. This
    is really just a routine for processing edges.
    */
    action DrawScanlines(PixelMap pixelMap, Color color)
        integer scanline = 0
        Array<GlyphOutlineEdge> newEdges

        integer j = 0

        repeat while scanline < scanlineBuckets:GetSize()
            j = 0
            newEdges = scanlineBuckets:Get(scanline)
            // add edges to active table
            repeat while j < newEdges:GetSize()
                GlyphOutlineEdge edge = newEdges:Get(j)
                InsertEdgeIntoActiveEdgeList(edge)
                j = j + 1
            end

            // remove completed edges
            RemoveEdgeFromActiveEdgeList(scanline+scanlineMinimum)

            // draw scanlines
            FillBetweenEdges(pixelMap, scanline+scanlineMinimum, color)

            // update the x-intercepts for each edge on the next scanline
            UpdateEdgeXPositions(scanline+scanlineMinimum+1)

            // sort the edges by their x-intercept, ascending
            SortActiveEdgeList()

            scanline = scanline + 1
        end
    end
    
    /*
    This action updates the current x-position of every edge in the active edge list
    For straight lines, it calculates the x-intercept of the line
    For Bezier curves, it indexes into the array of x-intercepts that have been
    calculated when the edge was created. Again, that function is almost certainly
    wrong and needs to be looked at.
    */
    action UpdateEdgeXPositions(integer scanline)
        integer i = 0

        repeat while i < activeEdgeListLeft:GetSize()
            GlyphOutlineEdge edge = activeEdgeListLeft:Get(i)
            edge:UpdateCurrentXPosition()
            i = i + 1
        end

        i = 0

        repeat while i < activeEdgeListRight:GetSize()
            GlyphOutlineEdge edge = activeEdgeListRight:Get(i)
            edge:UpdateCurrentXPosition()
            i = i + 1
        end
    end

    /*
    This action sorts the active edge lists in ascending x-value order. The custom
    sort is implemented in the GlyphOutlineEdge class, but has been tested extensively
    and works properly.
    */
    action SortActiveEdgeList()
        activeEdgeListLeft:Sort()  
        activeEdgeListRight:Sort()
    end

    /*
    This is the straight line anti-alias action. It uses the same method of
    super sampling used by the Bezier anti-alias action, although this is much
    easier to implement and understand. Reference TestCoverage or Google super
    sampling to understand this process.

    Again, at some point it would be nice to consolidate the two methods, if possible.
    */
    action AntiAliasLineSegment(PixelMap pixelMap, GlyphOutlineEdge edge, integer yScanline)
        Color color
        number yMin = edge:GetYMinimum()
        number yMax = edge:GetYMaximum()
        number yScan = yScanline

        integer subPixelsCovered = 0
        number sampleSize = 256.0
        number sampleIncrement = 1 / math:SquareRoot(sampleSize)

        number xStart = math:Floor(edge:GetCurrentXPosition())
        number xIntercept = edge:GetCurrentXPosition()

        repeat while yScan < yScanline + 1
            if yScan >= yMin and yScan <= yMax
                number xScan = xStart
                repeat while xScan < xStart + 1
                    if edge:GetIsAscending()
                        if xScan >= xIntercept
                            subPixelsCovered = subPixelsCovered + 1
                        end
                    else
                        if xScan <= xIntercept
                            subPixelsCovered = subPixelsCovered + 1
                        end                        
                    end   
                xScan = xScan + sampleIncrement
                end
            end    
            yScan = yScan + sampleIncrement
        end
        
        color:SetColor(0, 0, 0, subPixelsCovered/sampleSize)
        pixelMap:SetPixel(cast(integer, xStart) - xMinimum, pixelMap:GetHeight() - 1 - yScanline + scanlineMinimum, color)
    end

    /*
    This action is a real monster, and I would not be at all surprised if this
    needs a ton of work to work correctly with the Bezier curve anti-aliasing.
    I'll do my best to explain what is going on here. This may need to be
    entirely rewritten/figured out, but I still think the x-intercept calculations
    should be the top priority, since without those being correct nothing else is
    really going to work.

    Anyway, this action draws a line from one ascending edge to one descending edge,
    filling the glyph in. In my time working on this, this proved to have the most
    edge cases and be the most difficult to figure things out on. It's surprising
    where issues can pop up.

    The idea is simple. Take the left-most ascending edge (lowest x-value), find
    the left-most descending edge (lowest x-value) and draw a line betweem them.
    Apparently, the lists are always supposed to be balanced by some geometric
    property (you read about this in the rasterization.txt file) but I never got
    this to happen. Again, I think this is realted to some weird rounding problem,
    or perhaps removing/adding edges too early. If the lists were balanced, then
    you would simply iterate over both lists, pair the edges at the same index
    value, and call it a day. If you can figure out how to balance the lists,
    that might simplify this greatly.

    As it stands now, this is extremely convoluted and has a bunch of stuff in it
    to handle all kinds of edge cases and oddities. Really take some time to
    understand what is happening here.
    */
    action FillBetweenEdges(PixelMap pixelMap, integer scanline, Color color)
        // iterator for the left list
        integer i = 0
        // used to iterate over the right list
        integer nextDescendingEdgeIndex = 0
        integer height = pixelMap:GetHeight() - 1

        // iterate through all the items in the active egde list
        repeat while i < activeEdgeListLeft:GetSize()
            GlyphOutlineEdge edge1 = activeEdgeListLeft:Get(i)

            // grab a descending edge if one is available
            if nextDescendingEdgeIndex < activeEdgeListRight:GetSize()
                GlyphOutlineEdge edge2 = activeEdgeListRight:Get(nextDescendingEdgeIndex)
                // these will be used to describe certain types of what I call joints
                // which are special cases of the two edges being joined by a common vertex
                boolean joint1 = false
                boolean joint2 = false

                /*
                Two edges moving left to right, where the descending edge is to
                the left of the ascending edge and the ascending edge start y falls on
                the current scanline.
                */
                if edge2:GetEndXPosition() = edge1:GetStartXPosition() and edge2:GetEndYPosition() = edge1:GetStartYPosition() and (math:Floor(edge1:GetStartYPosition()) = scanline or math:Ceiling(edge1:GetStartYPosition()) = scanline)
                    joint1 = true
                end

                /*
                Two edges moving left to right, where the descending edge is to
                the right of the ascending edge and the ascending edge end y falls
                on the current scanline.
                */
                if edge2:GetStartXPosition() = edge1:GetEndXPosition() and edge2:GetStartYPosition() = edge1:GetEndYPosition() and (math:Floor(edge1:GetEndYPosition()) = scanline or math:Ceiling(edge1:GetEndYPosition()) = scanline)
                    joint2 = true
                end

                /*
                If we have an opening edge, it must have a closing edge. For an edge
                to be a closing edge, it must have an x value >= the opening x
                value. Special care needs to be taken when dealing with "joints"

                The following bits of code are methods to get the correct closing
                edge for an opening edge.
                */

                /*
                While the closing edge is to the left of the opening edge, and there
                are more closing edges, and we are not dealing with a joint,
                grab the next closing edge.
                */  
                repeat while edge2:GetCurrentXPosition() < edge1:GetCurrentXPosition() and (nextDescendingEdgeIndex+1) < activeEdgeListRight:GetSize() and not joint1 and not joint2
                    nextDescendingEdgeIndex = nextDescendingEdgeIndex + 1
                    edge2 = activeEdgeListRight:Get(nextDescendingEdgeIndex)
                end

                /*
                Now that we have a closing edge, we have to recheck if this edge
                forms a joint or not. These are the same checks as performed above.
                */
                if edge2:GetEndXPosition() = edge1:GetStartXPosition() and edge2:GetEndYPosition() = edge1:GetStartYPosition() and (math:Floor(edge1:GetStartYPosition()) = scanline or math:Ceiling(edge1:GetStartYPosition()) = scanline)
                    joint1 = true
                end

                if edge2:GetStartXPosition() = edge1:GetEndXPosition() and edge2:GetStartYPosition() = edge1:GetEndYPosition() and (math:Floor(edge1:GetEndYPosition()) = scanline or math:Ceiling(edge1:GetEndYPosition()) = scanline)
                    joint2 = true
                end

                /*
                If we have joints, we need to handle them in a special manner.

                For the first type of joint, the closing edge is always going to
                be to the left of the opening edge, so just grab the first
                closing edge to the right of the opening edge. Since joints can
                only happen once, we do not have to recheck the joint status of
                the new closing edge.

                For the second type of joint, the closing edge is always going
                to be to the right of the opening edge, so you may think we can
                just use it to close. I forget why now, but I found that in the
                case where the closing edge moves right to left I would get
                drop outs. So, if the closing edge is moving right to left, it
                grabs the next edge that is to the right of the opening edge.
                */
                if joint1
                    if edge1:GetMovingLeftToRight() or edge2:GetMovingLeftToRight() and (nextDescendingEdgeIndex+1) < activeEdgeListRight:GetSize()
                        edge2 = activeEdgeListRight:Get(nextDescendingEdgeIndex+1)
                        repeat while edge2:GetCurrentXPosition() < edge1:GetCurrentXPosition() and (nextDescendingEdgeIndex+1) < activeEdgeListRight:GetSize()
                            nextDescendingEdgeIndex = nextDescendingEdgeIndex + 1
                            edge2 = activeEdgeListRight:Get(nextDescendingEdgeIndex)
                        end
                    end
                end

                if joint2
                    if not edge2:GetMovingLeftToRight() and (nextDescendingEdgeIndex+1) < activeEdgeListRight:GetSize()
                        edge2 = activeEdgeListRight:Get(nextDescendingEdgeIndex+1)  
                        repeat while edge2:GetCurrentXPosition() < edge1:GetCurrentXPosition() and (nextDescendingEdgeIndex+1) < activeEdgeListRight:GetSize()
                            nextDescendingEdgeIndex = nextDescendingEdgeIndex + 1
                            edge2 = activeEdgeListRight:Get(nextDescendingEdgeIndex)
                        end
                    end
                end
                
                integer startX = 0
                integer endX = 0

                /*
                Now that we have an opening and closing edge pair, we just need
                to draw a line between the two points. We start drawing 1 x value
                to the right of the opening edge, so as to not overwrite the
                antialiased edge, and we stop 1 x value to the left of the closing
                edge for the same reason. Again, there may be a rounding issue here.

                Straight line anti-aliasing calls are done here, while Bezier curves
                have already been anti-aliased and placed on the pixelmap.
                */ 
                if edge1:GetIsBezierCurve()
                    startX = cast(integer, math:Floor(edge1:GetCurrentXPosition())) + 1
                else    // line segment
                    startX = cast(integer, math:Floor(edge1:GetCurrentXPosition())) + 1
                    AntiAliasLineSegment(pixelMap, edge1, scanline)
                end

                if edge2:GetIsBezierCurve()
                    endX = cast(integer, math:Floor(edge2:GetCurrentXPosition())) - 1
                else    // line segment
                    endX = cast(integer, math:Floor(edge2:GetCurrentXPosition())) - 1
                    AntiAliasLineSegment(pixelMap, edge2, scanline)
                end

                /*
                This may seem like a weird check after all that work to find a
                matching set of edges. But at small font sizes, it is possible
                to get a pair of edges that match and have no pixels between them,
                so there is nothing to fill in. Basically, if there is at least 1
                pixel between the ascending edge and the descending edge, fill it in.
                */
                if startX <= endX
                    pixelMap:DrawLine(startX - xMinimum, height - scanline + scanlineMinimum, endX - xMinimum, height - scanline + scanlineMinimum, color)
                end
            end
            /*
            Since we iterate through the list of closing edges every time we
            are looking at en opening edge, we reset that iterator to 0.
            */
            nextDescendingEdgeIndex = 0
            i = i + 1    
        end
    end

    /*
    This action scans the active edge lists, marks edges that are to be removed,
    and then removes the necessary edges from the lists. Honestly, the way I
    implemented this is terrible and it should be rewritten. But the idea is,
    if the current scanline is greater than the maximum y value for an edge,
    then that edge is finished and should be removed.
    */
    action RemoveEdgeFromActiveEdgeList(integer scanline)
        integer i = 0
        Array<integer> positionsToRemoveLeft
        Array<integer> positionsToRemoveRight
        repeat while i < activeEdgeListLeft:GetSize()
            GlyphOutlineEdge edge = activeEdgeListLeft:Get(i)
            if edge:GetYMaximum() = scanline
                positionsToRemoveLeft:Add(i)
            end
            i = i + 1
        end

        i = 0
        repeat while i < activeEdgeListRight:GetSize()
            GlyphOutlineEdge edge = activeEdgeListRight:Get(i)
            if edge:GetYMaximum() = scanline
                positionsToRemoveRight:Add(i)
            end
            i = i + 1
        end

        integer totalRemoved = 0
        
        i = 0
        repeat while i < positionsToRemoveLeft:GetSize()
            activeEdgeListLeft:RemoveAt(positionsToRemoveLeft:Get(i)-totalRemoved)
            totalRemoved = totalRemoved + 1
            i = i + 1
        end

        i = 0
        totalRemoved = 0
        repeat while i < positionsToRemoveRight:GetSize()
            activeEdgeListRight:RemoveAt(positionsToRemoveRight:Get(i)-totalRemoved)
            totalRemoved = totalRemoved + 1
            i = i + 1
        end
    end

    /*
    This action adds edges to one of the active edge lists. Ascending edges go
    into the left list, and descending edges go into the right list. When we insert,
    since we use a linked list, we iterate through the list until we find the
    appropriate spot to keep the list in ascending order.
    */
    action InsertEdgeIntoActiveEdgeList(GlyphOutlineEdge edge)
        boolean inserted = false
        if edge:GetIsAscending()    // add it to left list
            if activeEdgeListLeft:GetSize() = 0 // new list, just add the first item
                activeEdgeListLeft:AddToFront(edge)
            else    // already contains items, sort by start x value
                number x = edge:GetCurrentXPosition()
                integer i = 0
                repeat while i < activeEdgeListLeft:GetSize()
                    GlyphOutlineEdge edge2 = activeEdgeListLeft:Get(i)
                    if edge2:GetCurrentXPosition() >= x
                        activeEdgeListLeft:Add(i, edge)
                        i = activeEdgeListLeft:GetSize()
                        inserted = true
                    end

                    i = i + 1
                end
                if not inserted
                    activeEdgeListLeft:AddToEnd(edge)
                end
            end
        else    // add to right list
            if activeEdgeListRight:GetSize() = 0 // new list, just add the first item
                activeEdgeListRight:AddToFront(edge)
            else    // already contains items, sort by start x value
                number x = edge:GetCurrentXPosition()
                integer i = 0
                repeat while i < activeEdgeListRight:GetSize()
                    GlyphOutlineEdge edge2 = activeEdgeListRight:Get(i)
                    if edge2:GetCurrentXPosition() >= x
                        activeEdgeListRight:Add(i, edge)
                        i = activeEdgeListRight:GetSize()
                        inserted = true
                    end

                    i = i + 1
                end
                if not inserted
                    activeEdgeListRight:AddToEnd(edge)
                end
            end
        end
    end

    /*
    This action places an array of edges into a bucket. The buckets correspond
    to a y-value of the glyph, ranging from minY to maxY. Arrays of edges are
    placed into the bucket that matches that edge's lowest y-value. So if an edge
    has a yMin of 0, it goes into bucket 0.

    This action should be working correctly.
    */
    action PlaceEdgesIntoScanlineBuckets()
        integer totalScanlines = scanlineMaximum - scanlineMinimum
        integer i = 0
        
        // initialize buckets, we want one for each y-value of the glyph
        repeat while i <= totalScanlines
            Array<GlyphOutlineEdge> newEdges
            scanlineBuckets:Add(newEdges)

            i = i + 1
        end

        i = 0
        
        repeat while i < scanlineBuckets:GetSize()
            Array<GlyphOutlineEdge> newEdges = scanlineBuckets:Get(i)
            integer j = 0
            // iterate through the edges, and add them to their appropriate buckets
            // as explained above. Each edge goes in exactly one bucket
            // we do not process horizontal edges
            repeat while j < edges:GetSize()
                GlyphOutlineEdge edge = edges:Get(j)
                if edge:GetYMinimum() = i + scanlineMinimum and not edge:GetIsHorizontal()
                    newEdges:Add(edge)
                end

                j = j + 1
            end        

            i = i + 1
        end

    end

    /*
    This action takes the points from a BezierCurveGlyphPoints object and turns
    them into edges, both straight lines and Bezier curves. This has been tested
    a lot and should be correct, so I will not go into a lot of details since
    it's not strictly related to anti-aliasing. Basically, it looks through
    the points, and when it finds two consecutive on-curve points, it creates
    a normal edge. When it finds an on-curve, off-curve, on-curve sequence of
    points, it creates a Bezier curve edge. There are some weird situational cases
    covered here, such as a closing loop on an O, or moving from the outer ring
    to the inner ring of an O, but they are minor implementation details.

    Created edges are added to the global edge list.

    This action also updates the extrema for the glyph. Seemed like a convenient
    place to do that.

    If you get totally stuck and you think the edges are being made incorrectly,
    you are going to want to read the BezierCurveGlyphPoints documentation, specifically
    what the coordinates and endpoints represent. Then look at the edge creation
    actions in the GlyphOutlineEdge class, and work things out on paper. It is
    possible there are still edge case errors here, but I would be surprised.
    Best to focus your efforts elsewhere, and only look here as a last resort or
    if you're sure the edges are wrong.
    */
    action CreateGlyphOutlineEdges(Array<CoordinateVector> coordinates, Array<integer> endpoints)
        CoordinateVector startPoint
        CoordinateVector nextPoint
        CoordinateVector controlPoint
        integer endpointIndex = 1
        integer endpoint = endpoints:Get(0)
        integer contourStartIndex = 0
        integer i = 0
        integer edgeNumber = 1

        repeat while i < coordinates:GetSize()
            GlyphOutlineEdge edge
            startPoint = coordinates:Get(i)

            if startPoint:IsOnCurve()   // only add edges between on curve points
                if i = endpoint  // need to get the first point that started this contour
                    nextPoint = coordinates:Get(contourStartIndex)
                    if endpointIndex < endpoints:GetSize()
                        endpoint = endpoints:Get(endpointIndex)
                        endpointIndex = endpointIndex + 1
                    end
                    contourStartIndex = i + 1

                else    // next point is just the next point in the list
                    nextPoint = coordinates:Get(i+1)
                    if not nextPoint:IsOnCurve()    // next point is a control point, get the next point
                        controlPoint = nextPoint
                        edge:SetIsBezierCurve(true)
                        if (i+1) not= endpoint    // not at the end of the outline
                            nextPoint = coordinates:Get(i+2)
                        else    // i+1 is endpoint, need to get the point that starts the contour
                            nextPoint = coordinates:Get(contourStartIndex)
                            if endpointIndex < endpoints:GetSize()
                                endpoint = endpoints:Get(endpointIndex)
                                endpointIndex = endpointIndex + 1
                            end
                        contourStartIndex = i + 2    
                        end
                    end
                end
                
                if edge:GetIsBezierCurve()
                    edge:CreateBezierEdge(startPoint, nextPoint, controlPoint, edgeNumber)
                    edgeNumber = edgeNumber + 1
                else
                    edge:CreateEdge(startPoint, nextPoint, edgeNumber)
                    edgeNumber = edgeNumber + 1
                end

                if edge:GetYMinimum() < scanlineMinimum
                    scanlineMinimum = edge:GetYMinimum()
                end

                if edge:GetYMaximum() > scanlineMaximum
                    scanlineMaximum = edge:GetYMaximum()
                end

                if edge:GetStartXPosition() < xMinimum
                    xMinimum = cast(integer, math:Ceiling(edge:GetStartXPosition()))
                end
//made change from:
//                if edge:GetStartXPosition() > xMaximum 
//                    xMaximum = cast(integer, math:Ceiling(edge:GetStartXPosition()))
//                end

                if edge:GetEndXPosition() > xMaximum
                    xMaximum = cast(integer, math:Ceiling(edge:GetEndXPosition()))
                end

                edges:Add(edge)
            end
            i = i + 1
        end
    integer j = 0
    repeat while j < edges:GetSize()
        GlyphOutlineEdge newEdge = edges:Get(j)
        if newEdge:GetIsBezierCurve()
            newEdge:FindXIntercepts()
        end
        j = j + 1
    end
    end
    

action GetGlyphWidth() returns integer
    return me:glyphWidth
end

action GetGlyphHeight() returns integer
    return me:glyphHeight
end

action GetScanlineMaximum() returns integer
    return me:scanlineMaximum
end

action EmptyBuckets()
    edges:Empty()
    activeEdgeListLeft:Empty()
    activeEdgeListRight:Empty()
    scanlineBuckets:Empty()
end

action DrawGlyph(BezierCurveGlyphPoints outline, integer xOffset, integer yOffset, Color color, TrueTypeFileInformation information) returns FontDrawable
    FontBoundingBox box = outline:GetBoundingBox() 
    integer highPoint = CalculateScaledCoordinate(box:GetYMaximum(), pixelSize, information:GetUnitsPerEm()) + 1
    integer lowPoint = CalculateScaledCoordinate(box:GetYMinimum(), pixelSize, information:GetUnitsPerEm()) - 1
    output "Inside Rasterizer, outline has points: "
    outline:DisplayCoordinates()

    Format format = SetupFormat()
    
    PixelMap pixelMap
    Blending blending
    blending:SetValue(blending:NONE)
    pixelMap:SetBlending(blending)
    Texture texture
    Drawable drawable
    Array<CoordinateVector> coordinates
    Array<integer> endpoints
    
    me:edges:Empty()
    me:activeEdgeListLeft:Empty()
    me:activeEdgeListRight:Empty()
    me:scanlineBuckets:Empty()

    coordinates = outline:GetPoints()
    if coordinates:IsEmpty()
    FontDrawable glyph
        glyph:SetDrawable(undefined)
        glyph:SetXMaximum(xMaximum)
        glyph:SetYMaximum(scanlineMaximum)
        glyph:SetXMinimum(xMinimum)
        glyph:SetYMinimum(scanlineMinimum)
        glyph:SetHeightFromBaseline(CalculateScaledCoordinate(scanlineMaximum, pixelSize, emSize))
        return glyph
    end
    endpoints = outline:GetContourEndpoints()

    outline:ScaleBezierPointsToFontSize(pixelSize, emSize)
    outline:DisplayCoordinates()
    coordinates = outline:GetPoints()
    FindGlyphWidthAndHeight(outline)

    pixelMap:CreatePixelMap(me:glyphWidth, me:glyphHeight, format)
    CreateGlyphOutlineEdges(coordinates, endpoints)
    integer i = 0
    repeat while i < edges:GetSize()
        GlyphOutlineEdge newEdge = edges:Get(i)
        if newEdge:GetIsBezierCurve()
            newEdge:FindXIntercepts()
        end
        i = i + 1
    end

    PlaceEdgesIntoScanlineBuckets()
    TestAntiAlias(pixelMap)
    DrawScanlines(pixelMap, color)
    //texture:FinishLoadingAsynchronously(undefined, pixelMap, format, false, undefined)
    texture:LoadFromPixelMap(pixelMap)
    drawable:Load(texture)
    xOffset = xOffset + pixelSize
    if(xOffset >= screenXSize)
        xOffset = 0
        yOffset = yOffset + pixelSize
    end
    //drawable:SetPosition(10 + xOffset, scanlineMinimum + yOffset)
    FontDrawable glyph
    glyph:SetDrawable(drawable)
    glyph:SetXMaximum(xMaximum)
    glyph:SetYMaximum(scanlineMaximum)
    glyph:SetXMinimum(xMinimum)
    glyph:SetYMinimum(scanlineMinimum)
    glyph:SetHeightFromBaseline(CalculateScaledCoordinate(scanlineMaximum, pixelSize, emSize))

    return glyph
end

action CalculateScaledCoordinate(integer coordinate, integer pixelSize, integer emSize) returns integer
    return coordinate * pixelSize / emSize
end

private action SetupFormat() returns Format
    Format format
    format:SetValue(format:RGBA8888)
    return format
end

private action SetupPixelMap(number width, number height, Format format) returns PixelMap
    Color color
    PixelMap pixelMap
    pixelMap:SetColor(color:Black())
    pixelMap:CreatePixelMap(cast(integer, width), cast(integer, height), format)
    return pixelMap
end

action SetEmSize(integer emSize)
    me:emSize = emSize
end

action GetEmSize() returns integer
    return me:emSize
end

action SetMaxXSize(integer newSize)
    me:xMaximum = newSize
end

action SetMaxYSize(integer newSize)
    me:scanlineMaximum = newSize
end

action SetSize(integer size)
    me:pixelSize = size
    me:xMaximum = cast(integer, 2*size)
    me:scanlineMaximum = cast(integer, 1.5*size)
end

end